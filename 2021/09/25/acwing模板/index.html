<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible"><meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,minimum-scale=1,user-scalable=no"><meta name="renderer" content="webkit"><meta name="color-scheme" content="dark light"><meta name="author" content="ainexur"><meta name="description" content="温故 知新"><meta name="keywords" content="博客"><title>Acwing模板</title><link rel="icon" type="image/x-icon" href="/images/favicon.ico"><link rel="stylesheet" href="//at.alicdn.com/t/font_3242539_utq6ykfq7z.css"><link rel="stylesheet" light-src="https://cdn.staticfile.org/highlight.js/11.5.0/styles/default.min.css" dark-src="https://cdn.staticfile.org/highlight.js/11.5.0/styles/tokyo-night-dark.min.css"><link rel="stylesheet" href="https://fonts.font.im/css?family=Noto+Serif" as="font"><link href="/style/index.css" rel="stylesheet"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="寻人启事" type="application/atom+xml">
</head><body><header class="page-header"><nav><ul class="router-list"><li class="nav-item"> <a href="/">主页</a></li><li class="nav-item"> <a href="/archives/">归档</a></li><li class="nav-item"> <a href="/atom.xml">RSS</a></li></ul><div class="mode-switch"><span class="iconfont icon-DarkTheme"></span></div></nav></header><main><section class="main-content"><section class="post-page"><div class="title-bar"><h1>Acwing模板</h1><div class="post-info"><span>2021-09-25 22:29:59</span><span class="tags"><a href="/tags/AcWing/">#AcWing</a><a href="/tags/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/">#算法基础</a></span></div></div><article> <div class="content"><h1 id="0-语法与STL"><a href="#0-语法与STL" class="headerlink" title="0 语法与STL"></a>0 语法与STL</h1><h2 id="0-1-重定向输入输出"><a href="#0-1-重定向输入输出" class="headerlink" title="0.1 重定向输入输出"></a>0.1 重定向输入输出</h2><pre><code class="hljs cpp"><span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;in.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin);
<span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;out.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout);</code></pre>



<h2 id="0-2-程序运行时间"><a href="#0-2-程序运行时间" class="headerlink" title="0.2 程序运行时间"></a>0.2 程序运行时间</h2><pre><code class="hljs cpp"><span class="hljs-type">double</span> start,finish; <span class="hljs-comment">/* 开始时间,结束时间 */</span> 
start=(<span class="hljs-type">double</span>)<span class="hljs-built_in">clock</span>(); <span class="hljs-comment">/* 我的time.h内没有CLOCKS_PER_SEC */</span> 
<span class="hljs-comment">//中间放要测试的代码</span>
finish=(<span class="hljs-type">double</span>)<span class="hljs-built_in">clock</span>(); 
<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.4fms&quot;</span>,(finish-start));</code></pre>



<h2 id="0-3"><a href="#0-3" class="headerlink" title="0.3"></a>0.3</h2><p>c++常用函数</p>
<table>
<thead>
<tr>
<th>函数名</th>
<th>解释</th>
<th>返回值类型</th>
</tr>
</thead>
<tbody><tr>
<td><code>isalpha()</code></td>
<td>判断是否是字母</td>
<td>bool</td>
</tr>
<tr>
<td><code>tolower()</code></td>
<td>将字符转为小写</td>
<td>char</td>
</tr>
<tr>
<td><code>ceil()</code></td>
<td>向上取整</td>
<td></td>
</tr>
<tr>
<td><code>floor()</code></td>
<td>向下取整</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>函数名称	返回值【输入是字符char】<br>isalnum()	如果是字母或数字，返回true<br>isalpha()	如果是字母，返回true<br>isdigit()	如果是数字，返回true<br>islower()	如果是小写字母，返回true<br>ispunct()	<br>如果是标点符号，返回true</p>
<p>isspace()	如果是空白字符，包括空格、进纸、换行符、回车、制表符等，返回true<br>isupper()	如果是大写字符，返回true<br>tolower()	如果是大写字符，返回其小写<br>toupper()	如果是小写字符，返回其大写<br>isxdigit()	如果是16进制数，返回true，如0-9、a-f、A-F<br>iscntrl()	如果是控制字符，返回true<br>isgraph()	如果是除空格以外的打印字符，返回true<br>isprint()	如果是打印字符，返回true</p>
<h3 id="0-1-1-结构体定义（带初始化）"><a href="#0-1-1-结构体定义（带初始化）" class="headerlink" title="0.1.1 结构体定义（带初始化）"></a>0.1.1 结构体定义（带初始化）</h3><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;
    <span class="hljs-type">int</span> x, y;
    <span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> _x, <span class="hljs-type">int</span> _y) &#123;
        x = _x;
        y = _y;
    &#125;
&#125;;</code></pre>

<h2 id="0-4-对拍"><a href="#0-4-对拍" class="headerlink" title="0.4 对拍"></a>0.4 对拍</h2><h1 id="1-基础算法"><a href="#1-基础算法" class="headerlink" title="1 基础算法"></a>1 基础算法</h1><h2 id="1-1-排序"><a href="#1-1-排序" class="headerlink" title="1.1 排序"></a>1.1 排序</h2><h3 id="1-1-1-快速排序"><a href="#1-1-1-快速排序" class="headerlink" title="1.1.1 快速排序"></a>1.1.1 快速排序</h3><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;
    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;
    <span class="hljs-type">int</span> x = q[(l + r) / <span class="hljs-number">2</span>], i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>;
    <span class="hljs-keyword">while</span> (i &lt; j) &#123;
        <span class="hljs-keyword">while</span> (q[++ i] &lt; x);
        <span class="hljs-keyword">while</span> (q[-- j] &gt; x);
        <span class="hljs-keyword">if</span> (i &lt; j) <span class="hljs-built_in">swap</span>(q[i], q[j]);
    &#125;
    <span class="hljs-built_in">quick_sort</span>(q, l, j);
    <span class="hljs-built_in">quick_sort</span>(q, j + <span class="hljs-number">1</span>, r);
&#125;</code></pre>

<h3 id="1-1-2-快速选择"><a href="#1-1-2-快速选择" class="headerlink" title="1.1.2 快速选择"></a>1.1.2 快速选择</h3><p>选择数组里第k小数</p>
<pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> k)</span> </span>&#123;
    <span class="hljs-keyword">if</span> (l == r) <span class="hljs-keyword">return</span> a[l];
    <span class="hljs-type">int</span> x = a[(l + r) &gt;&gt; <span class="hljs-number">1</span>], i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>;
    <span class="hljs-keyword">while</span> (i &lt; j) &#123;
        <span class="hljs-keyword">while</span> (a[ ++ i] &lt; x);
        <span class="hljs-keyword">while</span> (a[ -- j] &gt; x);
        <span class="hljs-keyword">if</span> (i &lt; j) <span class="hljs-built_in">swap</span>(a[i], a[j]);
    &#125; 
    <span class="hljs-type">int</span> sl = j - l + <span class="hljs-number">1</span>;
    <span class="hljs-keyword">if</span> (sl &gt;= k) <span class="hljs-keyword">return</span> <span class="hljs-built_in">quick_sort</span>(l, j, k);
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">quick_sort</span>(j + <span class="hljs-number">1</span>, r, k - sl);

&#125;</code></pre>



<h3 id="1-1-2-归并排序"><a href="#1-1-2-归并排序" class="headerlink" title="1.1.2 归并排序"></a>1.1.2 归并排序</h3><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;
    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;
    <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;
    <span class="hljs-built_in">merge_sort</span>(q, l, mid),<span class="hljs-built_in">merge_sort</span>(q, mid + <span class="hljs-number">1</span>, r);
    
    <span class="hljs-type">int</span> i = l, j = mid + <span class="hljs-number">1</span>, k = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)
        tmp[k ++] = q[i] &lt;= q[j] ? q[i ++] : q[j ++];
        
    <span class="hljs-keyword">while</span> (i &lt;= mid) tmp[k ++] = q[i ++];
    <span class="hljs-keyword">while</span> (j &lt;= r) tmp[k ++] = q[j ++];
    
    <span class="hljs-keyword">for</span> (i = l, j = <span class="hljs-number">0</span>; i &lt;= r; i ++, j ++) q[i] = tmp[j];
&#125;</code></pre>





<h2 id="1-2-查找"><a href="#1-2-查找" class="headerlink" title="1.2 查找"></a>1.2 查找</h2><h3 id="1-2-1-二分查找"><a href="#1-2-1-二分查找" class="headerlink" title="1.2.1 二分查找"></a>1.2.1 二分查找</h3><p>x的左边界</p>
<pre><code class="hljs cpp"><span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>;
<span class="hljs-keyword">while</span> (l &lt; r) &#123;
    <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;
    <span class="hljs-keyword">if</span> (q[mid] &gt;= x) r = mid;
    <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;
&#125;</code></pre>

<p>x的右边界</p>
<pre><code class="hljs cpp"><span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>;
<span class="hljs-keyword">while</span> (l &lt; r) &#123;
    <span class="hljs-type">int</span> mid = l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>;
    <span class="hljs-keyword">if</span> (q[mid] &lt;= x) l = mid;
    <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;
&#125;
cout &lt;&lt; l &lt;&lt; endl;</code></pre>

<h2 id="1-3-高精度"><a href="#1-3-高精度" class="headerlink" title="1.3 高精度"></a>1.3 高精度</h2><h3 id="1-3-1-高精度加法"><a href="#1-3-1-高精度加法" class="headerlink" title="1.3.1 高精度加法"></a>1.3.1 高精度加法</h3><pre><code class="hljs cpp"><span class="hljs-comment">//C = A + B</span>
<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">add</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, vector&lt;<span class="hljs-type">int</span>&gt; &amp;B)</span> </span>&#123;
    vector&lt;<span class="hljs-type">int</span>&gt; C;
    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>() || i &lt; B.<span class="hljs-built_in">size</span>(); i ++) &#123;
        <span class="hljs-keyword">if</span> (i &lt; A.<span class="hljs-built_in">size</span>()) t += A[i];
        <span class="hljs-keyword">if</span> (i &lt; B.<span class="hljs-built_in">size</span>()) t += B[i];
        C.<span class="hljs-built_in">push_back</span>(t % <span class="hljs-number">10</span>);
        t /= <span class="hljs-number">10</span>;
    &#125;
    <span class="hljs-keyword">if</span> (t) C.<span class="hljs-built_in">push_back</span>(t);
    <span class="hljs-keyword">return</span> C;
&#125;</code></pre>

<h3 id="1-3-2-高精度减法"><a href="#1-3-2-高精度减法" class="headerlink" title="1.3.2 高精度减法"></a>1.3.2 高精度减法</h3><pre><code class="hljs cpp"><span class="hljs-comment">//(bool) A &gt;= B</span>
<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, vector&lt;<span class="hljs-type">int</span>&gt; &amp;B)</span> </span>&#123;
    <span class="hljs-keyword">if</span> (A.<span class="hljs-built_in">size</span>() != B.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> A.<span class="hljs-built_in">size</span>() &gt; B.<span class="hljs-built_in">size</span>();
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = A.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i --) 
        <span class="hljs-keyword">if</span> (A[i] != B[i])
            <span class="hljs-keyword">return</span> A[i] &gt; B[i];
    
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
&#125;
<span class="hljs-comment">//C = A - B</span>
<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sub</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, vector&lt;<span class="hljs-type">int</span>&gt; &amp;B)</span> </span>
<span class="hljs-function">    <span class="hljs-title">if</span> <span class="hljs-params">(!cmp(A, B))</span> <span class="hljs-keyword">return</span> <span class="hljs-title">sub</span><span class="hljs-params">(B, A)</span></span>;
    vector&lt;<span class="hljs-type">int</span>&gt; C;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, t = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>(); i ++ ) &#123;
        t = A[i] - t;
        <span class="hljs-keyword">if</span> (i &lt; B.<span class="hljs-built_in">size</span>()) t -= B[i];
        C.<span class="hljs-built_in">push_back</span>((t + <span class="hljs-number">10</span>) % <span class="hljs-number">10</span>);
        <span class="hljs-keyword">if</span> (t &lt; <span class="hljs-number">0</span>) t = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">else</span> t = <span class="hljs-number">0</span>;
    &#125;
    
    <span class="hljs-keyword">while</span> (C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>(); 	<span class="hljs-comment">//去掉前导零</span>
    <span class="hljs-keyword">return</span> C;
&#125;
</code></pre>

<h3 id="1-3-3-高精度乘法（vector-int"><a href="#1-3-3-高精度乘法（vector-int" class="headerlink" title="1.3.3 高精度乘法（vector * int)"></a>1.3.3 高精度乘法（vector * int)</h3><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">mul</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, <span class="hljs-type">int</span> b)</span> </span>&#123;
    vector&lt;<span class="hljs-type">int</span>&gt; C;
    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>() || t; i ++) &#123;
        <span class="hljs-keyword">if</span> (i &lt; A.<span class="hljs-built_in">size</span>()) t += A[i] * b;
        C.<span class="hljs-built_in">push_back</span>(t % <span class="hljs-number">10</span>);
        t /= <span class="hljs-number">10</span>;
    &#125;
    <span class="hljs-keyword">while</span> (C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();
    <span class="hljs-keyword">return</span> C;
&#125;</code></pre>

<h3 id="1-3-4-高精度除法"><a href="#1-3-4-高精度除法" class="headerlink" title="1.3.4 高精度除法"></a>1.3.4 高精度除法</h3><pre><code class="hljs cpp"><span class="hljs-comment">//C = 商， r = 余</span>
<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">div</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> &amp;r)</span> </span>&#123;
    vector&lt;<span class="hljs-type">int</span>&gt; C;
    r = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = A.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i --) &#123;
        r = r * <span class="hljs-number">10</span> + A[i];
        C.<span class="hljs-built_in">push_back</span>(r / b);
        r %= b;
    &#125;
    <span class="hljs-built_in">reverse</span>(C.<span class="hljs-built_in">begin</span>(), C.<span class="hljs-built_in">end</span>());
    <span class="hljs-keyword">while</span> (C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();
    <span class="hljs-keyword">return</span> C;
&#125;</code></pre>

<h2 id="1-4-前缀和差分"><a href="#1-4-前缀和差分" class="headerlink" title="1.4 前缀和差分"></a>1.4 前缀和差分</h2><h3 id="1-4-1-一维前缀和"><a href="#1-4-1-一维前缀和" class="headerlink" title="1.4.1 一维前缀和"></a>1.4.1 一维前缀和</h3><blockquote>
<p>含义:	s[i] &#x3D; a[1] + a[2] + … + a[i]</p>
</blockquote>
<pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]);
<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) s[i] = s[i - <span class="hljs-number">1</span>] + a[i];</code></pre>

<h3 id="1-4-2-二维前缀和"><a href="#1-4-2-二维前缀和" class="headerlink" title="1.4.2 二维前缀和"></a>1.4.2 二维前缀和</h3><blockquote>
<p>含义: s[i][j] &#x3D; a[0][0] 与a[i][j] 组成的矩阵的和</p>
<p>二维矩阵和： s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1]</p>
</blockquote>
<pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++)
            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i][j]);
            
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++) 
            s[i][j] = s[i - <span class="hljs-number">1</span>][j] + s[i][j - <span class="hljs-number">1</span>] - s[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + a[i][j];</code></pre>

<h3 id="1-4-3-一维差分"><a href="#1-4-3-一维差分" class="headerlink" title="1.4.3 一维差分"></a>1.4.3 一维差分</h3><pre><code class="hljs cpp"><span class="hljs-type">int</span> a[N], b[N];

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> x)</span> </span>&#123;
    b[l] += x;
    b[r + <span class="hljs-number">1</span>] -= x;
&#125;</code></pre>

<h3 id="1-4-4-二维差分"><a href="#1-4-4-二维差分" class="headerlink" title="1.4.4 二维差分"></a>1.4.4 二维差分</h3><pre><code class="hljs cpp"><span class="hljs-type">int</span> a[N][N], b[N][N];

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x1, <span class="hljs-type">int</span> y1, <span class="hljs-type">int</span> x2, <span class="hljs-type">int</span> y2, <span class="hljs-type">int</span> x)</span> </span>&#123;
    b[x1][y1] += x;
    b[x2 + <span class="hljs-number">1</span>][y1] -= x; 
    b[x1][y2 + <span class="hljs-number">1</span>] -= x;
    b[x2 + <span class="hljs-number">1</span>][y2 + <span class="hljs-number">1</span>] += x;
&#125;</code></pre>

<h2 id="1-5-双指针算法"><a href="#1-5-双指针算法" class="headerlink" title="1.5 双指针算法"></a>1.5 双指针算法</h2><p><strong>核心：将<code>O(n^2)</code>的算法， 利用双指针能降为<code>O(n)</code></strong></p>
<p><strong>思路：先写一个暴力做法， 看一下i和j有没有单调规律</strong></p>
<h3 id="1-5-1-模板1"><a href="#1-5-1-模板1" class="headerlink" title="1.5.1 模板1"></a>1.5.1 模板1</h3><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; n; i ++) &#123;
    <span class="hljs-comment">//加入i</span>
    s[a[i]] ++;	<span class="hljs-comment">//s[]，计数器</span>
    <span class="hljs-comment">//假如不满足， 右移j直到满足</span>
    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">check</span>()) j ++;
    <span class="hljs-comment">//记录答案</span>
    ans = <span class="hljs-built_in">max</span>(ans, j - i + <span class="hljs-number">1</span>);
&#125;</code></pre>

<h2 id="1-6-位运算"><a href="#1-6-位运算" class="headerlink" title="1.6 位运算"></a>1.6 位运算</h2><h3 id="1-6-1-求n的二进制表示中第k位"><a href="#1-6-1-求n的二进制表示中第k位" class="headerlink" title="1.6.1 求n的二进制表示中第k位"></a>1.6.1 求<code>n</code>的二进制表示中第k位</h3><pre><code class="hljs cpp">(n &gt;&gt;) k &amp; <span class="hljs-number">1</span></code></pre>

<h3 id="1-6-2-x的最后一位1"><a href="#1-6-2-x的最后一位1" class="headerlink" title="1.6.2 x的最后一位1"></a>1.6.2 x的最后一位1</h3><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;
    <span class="hljs-keyword">return</span> x &amp; -x; 	<span class="hljs-comment">// x &amp; (~x + 1) </span>
&#125;</code></pre>

<h2 id="1-7-离散化"><a href="#1-7-离散化" class="headerlink" title="1.7 离散化"></a>1.7 离散化</h2><p>大范围内少数量的数， 映射到从0开始的一段连续的值（下标）；</p>
<ol>
<li>可能存在重复元素 （去重）</li>
<li>如何算出x离散化后的值 （二分）</li>
</ol>
<pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;
<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">300010</span>;
<span class="hljs-type">int</span> n, m;
<span class="hljs-type">int</span> a[N], s[N];
vector&lt;<span class="hljs-type">int</span>&gt; alls;
vector&lt;PII&gt; add, query;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;
    <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = alls.<span class="hljs-built_in">size</span>() <span class="hljs-number">-1</span> ;
    <span class="hljs-keyword">while</span> (l &lt; r) &#123;
        <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (alls[mid] &gt;= x) r = mid;
        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;
    &#125;
    <span class="hljs-keyword">return</span> r + <span class="hljs-number">1</span>;
&#125;</code></pre>





<h2 id="1-8-区间合并"><a href="#1-8-区间合并" class="headerlink" title="1.8 区间合并"></a>1.8 区间合并</h2><p>将存在交集的区间合并为一个区间。</p>
<p>思路：</p>
<ol>
<li>按左边界为主序、右边界为次序排序</li>
<li>初始化一个初始区间（初始手里的区间）（起始边界都为负无穷）</li>
<li>从左往右遍历排序好的区间， 做如下合并操作：<ol>
<li>如果遍历到的区间左边界大于当前手里区间的右边界， 说明从该区间往后的区间都不可能与当前区间合并（即不重合、没有交集）（因为区间是排序好的），则手里区间是一个已合并后的确定区间，将该区间加入合并后的数组。手里区间替换为当前区间</li>
<li>如果遍历到的区间左边界小于当前手里区间的右边界， 说明两个区间存在交集、可以合并。则合并后的区间右边界为两者区间的最右边界，左边界不变（因为是按左边界排序，手里区间的左边界必&lt;&#x3D;当前区间的左边界， 所以不用考虑左边界）</li>
</ol>
</li>
</ol>
<pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;PII&gt; &amp;segs)</span> </span>&#123;
    vector&lt;PII&gt; res;
    <span class="hljs-built_in">sort</span>(segs.<span class="hljs-built_in">begin</span>(), segs.<span class="hljs-built_in">end</span>());
    
    <span class="hljs-type">int</span> st = <span class="hljs-number">-2e9</span>, ed = <span class="hljs-number">-2e9</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> seg : segs) 
        <span class="hljs-keyword">if</span> (ed &lt; seg.first) &#123;
            <span class="hljs-keyword">if</span> (st != <span class="hljs-number">-2e9</span>) res.<span class="hljs-built_in">push_back</span>(&#123;st, ed&#125;);
            st = seg.first, ed = seg.second;
        &#125; <span class="hljs-keyword">else</span> 
            ed = <span class="hljs-built_in">max</span>(ed, seg.second);
            
    <span class="hljs-keyword">if</span> (st != <span class="hljs-number">-2e9</span>) res.<span class="hljs-built_in">push_back</span>(&#123;st, ed&#125;);
    
    segs = res;
&#125;</code></pre>

<h1 id="2-数据结构"><a href="#2-数据结构" class="headerlink" title="2 数据结构"></a>2 数据结构</h1><h2 id="2-1-单链表"><a href="#2-1-单链表" class="headerlink" title="2.1 单链表"></a>2.1 单链表</h2><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;
<span class="hljs-type">int</span> n;
<span class="hljs-type">int</span> head, e[N], ne[N], idx;

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;
    head = <span class="hljs-number">-1</span>, idx = <span class="hljs-number">0</span>;
&#125;
<span class="hljs-comment">//头插</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_to_head</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;
    e[idx] = x, ne[idx] = head, head = idx ++;
&#125;

<span class="hljs-comment">//k后插x</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> x)</span> </span>&#123;
    e[idx] = x, ne[idx] = ne[k], ne[k] = idx ++;
&#125;

<span class="hljs-comment">//移除k后一个</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span> </span>&#123;
    ne[k] = ne[ne[k]];
&#125;</code></pre>

<h2 id="2-2-双链表"><a href="#2-2-双链表" class="headerlink" title="2.2 双链表"></a>2.2 双链表</h2><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;
<span class="hljs-type">int</span> n;
<span class="hljs-type">int</span> l[N], r[N], e[N], idx;

<span class="hljs-comment">//初始化</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;
    r[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>, l[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>, idx = <span class="hljs-number">2</span>;
&#125;

<span class="hljs-comment">//在k的右边插入x</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> x)</span> </span>&#123;
    e[idx] = x;
    l[idx] = k;
    r[idx] = r[k];
    l[r[k]] = idx;
    r[k] = idx ++;
&#125;

<span class="hljs-comment">//删除第k点</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span> </span>&#123;
    r[l[k]] = r[k];
    l[r[k]] = l[k];
&#125;</code></pre>

<h2 id="2-3-栈"><a href="#2-3-栈" class="headerlink" title="2.3 栈"></a>2.3 栈</h2><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;
<span class="hljs-type">int</span> q[N], tt = <span class="hljs-number">0</span>;
<span class="hljs-comment">//push</span>
q[tt ++] = x;

<span class="hljs-comment">//pop</span>
tt --;

<span class="hljs-comment">//empty?</span>
tt &gt;= <span class="hljs-number">0</span>?
</code></pre>



<h2 id="2-4-队列"><a href="#2-4-队列" class="headerlink" title="2.4 队列"></a>2.4 队列</h2><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;
<span class="hljs-type">int</span> q[N], hh, tt;
 <span class="hljs-comment">//push x – 向队尾插入一个数 x；</span>
q[++ tt] = x;
<span class="hljs-comment">// pop – 从队头弹出一个数；</span>
++ hh;
<span class="hljs-comment">// empty – 判断队列是否为空；</span>
cout &lt;&lt; (hh &lt;= tt ? <span class="hljs-string">&quot;NO&quot;</span> : <span class="hljs-string">&quot;YES&quot;</span>) &lt;&lt; endl;
<span class="hljs-comment">// query – 查询队头元素。</span>
cout &lt;&lt; q[hh] &lt;&lt; endl;</code></pre>



<h2 id="2-4-单调栈"><a href="#2-4-单调栈" class="headerlink" title="2.4 单调栈"></a>2.4 单调栈</h2><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;
<span class="hljs-type">int</span> stk[N], a[N], tt;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;
    tt = <span class="hljs-number">-1</span>;
    stk[ ++ tt] = <span class="hljs-number">-1</span>;
&#125;
<span class="hljs-comment">//单调递增</span>
<span class="hljs-keyword">while</span> (tt &amp;&amp; stk[tt] &gt;= a[i]) tt --;
stk[++ tt] = x;</code></pre>

<h2 id="2-5-滑动窗口-（单调队列）"><a href="#2-5-滑动窗口-（单调队列）" class="headerlink" title="2.5 滑动窗口 （单调队列）"></a>2.5 滑动窗口 （单调队列）</h2><ol>
<li>先考虑暴力解法</li>
<li>考虑能不能去掉其中一些元素</li>
<li>考虑去掉元素后是否构成单调队列</li>
</ol>
<pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1000010</span>;
<span class="hljs-type">int</span> n, k;
<span class="hljs-type">int</span> a[N], q[N];

<span class="hljs-type">int</span> hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">-1</span>;
<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) &#123;
    <span class="hljs-keyword">if</span> (hh &lt;= tt &amp;&amp; q[hh] &lt; i - k + <span class="hljs-number">1</span>) hh ++;
    <span class="hljs-comment">//单调递增</span>
    <span class="hljs-keyword">while</span> (hh &lt;= tt &amp;&amp; a[q[tt]] &gt;= a[i]) tt--;
    q[++ tt] = i;
    <span class="hljs-keyword">if</span> (i &gt;= k - <span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, a[q[hh]]);
&#125;</code></pre>

<h2 id="2-6-KMP"><a href="#2-6-KMP" class="headerlink" title="2.6 KMP"></a>2.6 KMP</h2><p>利用要匹配的字符串p的前字串的最大前后缀匹配长度，来对当前s[i] !&#x3D; p[j]时的，利用next[j + 1]的最大匹配度，直接跳转到s[i]匹配p[j]的阶段，从而减少重复计算，优化时间复杂度的算法。</p>
<p>重点：</p>
<ul>
<li>理解前后缀</li>
<li>理解为什么当前不匹配时可以跳到上一个最大匹配下标</li>
<li>理解next数组</li>
<li>理解next数组生成。</li>
</ul>
<h3 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h3><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>, M = <span class="hljs-number">1000010</span>;	<span class="hljs-comment">//字符数组的最大长度</span>
<span class="hljs-type">char</span> p[N], s[M];	<span class="hljs-comment">//s中匹配字符串p，从下标1开始</span>
<span class="hljs-type">int</span> ne[N];	<span class="hljs-comment">//p的next数组，从下标1开始</span></code></pre>
<h3 id="读入字符串"><a href="#读入字符串" class="headerlink" title="读入字符串"></a>读入字符串</h3><pre><code class="hljs cpp">cin &gt;&gt; n &gt;&gt; p + <span class="hljs-number">1</span> &gt;&gt; m &gt;&gt; s + <span class="hljs-number">1</span>;	<span class="hljs-comment">//n为字符串p的长度，m为字符串s的长度。两个字符数组都从1开始，方便代码</span></code></pre>

<h3 id="next数组"><a href="#next数组" class="headerlink" title="next数组"></a>next数组</h3><p>next[i] ：前i个字符形成的字符串的，前缀和后缀最大匹配</p>
<p>因为真前缀和真后缀不能取同样的起点和终点。同样的起点和终点不构成真前缀和真后缀。所以字符串长度最少为2，才有意义。</p>
<p>即长度小于2时，最大匹配为0。所以next[i]的i从2开始计算</p>
<ul>
<li><code>ne[i]</code>：前i个字符的前后缀最大匹配长度</li>
<li><code>j</code>：前i-1个字符的前后缀最大匹配长度</li>
</ul>
<pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>, j = <span class="hljs-number">0</span>; i &lt;= n; i ++) &#123;	<span class="hljs-comment">//i:前i个字符，j：前i-1个字符最大匹配长度</span>
    <span class="hljs-keyword">while</span> (j &amp;&amp; p[i] != p[j + <span class="hljs-number">1</span>]) j = ne[j];	<span class="hljs-comment">//寻找最大匹配j，可能为0</span>
    <span class="hljs-comment">//当j为0时说明前面的字串都没有任何匹配，就利用不到之前的匹配</span>
    <span class="hljs-comment">//p[i]!=p[j + 1]，假如前一个字串的最大匹配长度是j，那么说明[1.j] 和[i-j,i-1]两个字串相同，那么就需要判断p[i]和p[j+1]</span>
    <span class="hljs-comment">//1. p[i]==p[j+1]：即_abca时j=1, i=4;计算_abcab时，i=5, p[i]==p[j+1]，退出循环，即当前j对ne[i]是有效的</span>
    <span class="hljs-comment">//2. p[i]!=p[j+1]: 即_abca时j=1, i=4;计算_abcaa时，i=5, p[i]!=p[j+1]意味着最大匹配不能以p[i-1]作为开始，要以多少作为开始，就从j=ne[j]开始（这里也利用到KMP思想），在这里j=ne[j]=ne[1]=0，这时j=0退出循环，即从头开始计算最大匹配</span>
    <span class="hljs-keyword">if</span> (p[i] == p[j + <span class="hljs-number">1</span>]) j ++;	<span class="hljs-comment">//while循环处理好最大匹配</span>
    <span class="hljs-comment">//可能为0，当为0时意味着从新匹配，就需要判断p[i]是否和p[j+1]（记住这里j+1即第一个字符，字符串数组从下标1开始），相等则匹配度为1；</span>
    <span class="hljs-comment">//当j不为0即意味着不需要从头开始匹配，那么也意味着p[i]必定等于p[j+1]，这时候j++;</span>
    ne[i] = j;	<span class="hljs-comment">//记录值</span>
&#125;</code></pre>

<h3 id="KMP求S中的P的字符串匹配"><a href="#KMP求S中的P的字符串匹配" class="headerlink" title="KMP求S中的P的字符串匹配"></a>KMP求S中的P的字符串匹配</h3><p>利用next数组求字符串匹配（查找S中是否存在子串P）。</p>
<pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; i &lt;= m; i ++) &#123;	<span class="hljs-comment">//i=1从头开始，一开始的最大匹配是j=0</span>
    <span class="hljs-keyword">while</span> (j &amp;&amp; s[i] != p[j + <span class="hljs-number">1</span>]) j = ne[j];	<span class="hljs-comment">//对于当前s[i]，求可利用的j的最大值</span>
    <span class="hljs-comment">//如果j为0，意味从头开始匹配，j没法再退</span>
    <span class="hljs-comment">//否则s[i]!=p[j+1]时，j=ne[j]表示左移P串，即拿s[i]与p[ne[j]]比较</span>
    <span class="hljs-keyword">if</span> (s[i] == p[j + <span class="hljs-number">1</span>]) j ++;	<span class="hljs-comment">//如果两个字符相等，匹配长度+1</span>
    <span class="hljs-keyword">if</span> (j == n)  &#123;	 <span class="hljs-comment">//如果匹配长度=p的长度，则匹配成功</span>
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, i - n);
        j = ne[j]; <span class="hljs-comment">//求下一个匹配时，需要将j回退，也就是考虑当前s[i]!=p[j],</span>
    &#125;
&#125;</code></pre>



<h2 id="2-7-Trie树"><a href="#2-7-Trie树" class="headerlink" title="2.7 Trie树"></a>2.7 Trie树</h2><h4 id="2-7-1-字符串Trie"><a href="#2-7-1-字符串Trie" class="headerlink" title="2.7.1 字符串Trie"></a>2.7.1 字符串Trie</h4><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">20010</span>;
<span class="hljs-type">int</span> n;
<span class="hljs-type">int</span> s[N][<span class="hljs-number">26</span>], cnt[N], idx;

<span class="hljs-comment">//插入</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(string str)</span> </span>&#123;
    <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; str[i]; i++) &#123;
        <span class="hljs-type">int</span> u = str[i] - <span class="hljs-string">&#x27;a&#x27;</span>;
        <span class="hljs-keyword">if</span> (!s[p][u]) s[p][u] = ++idx;
        p = s[p][u];
    &#125;
    cnt[p] ++;
&#125;

<span class="hljs-comment">//查询</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(string str)</span> </span>&#123;
    <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; str[i]; i ++) &#123;
        <span class="hljs-type">int</span> u = str[i] - <span class="hljs-string">&#x27;a&#x27;</span>;
        <span class="hljs-keyword">if</span> (!s[p][u]) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        p = s[p][u];
    &#125;
    <span class="hljs-keyword">return</span> cnt[p];
&#125;</code></pre>



<h4 id="2-7-2-数字Trie"><a href="#2-7-2-数字Trie" class="headerlink" title="2.7.2 数字Trie"></a>2.7.2 数字Trie</h4><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">3100010</span>;
<span class="hljs-type">int</span> son[N][<span class="hljs-number">2</span>], idx;

<span class="hljs-comment">//0-1 Trie 插入x</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;
    <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">31</span>; i &gt;= <span class="hljs-number">0</span>; i --) &#123;
        <span class="hljs-type">int</span> u = (x &gt;&gt; i) &amp; <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (!son[p][u]) son[p][u] = ++ idx;
        p = son[p][u];
    &#125;
&#125;

<span class="hljs-comment">//查询最大异或值</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;
    <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>, ret = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">31</span>; i &gt;= <span class="hljs-number">0</span>; i --) &#123;
        <span class="hljs-type">int</span> u = (x &gt;&gt; i) &amp; <span class="hljs-number">1</span>;
        ret &lt;&lt;= <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (son[p][!u]) ret += <span class="hljs-number">1</span>, p = son[p][!u];
        <span class="hljs-keyword">else</span> p = son[p][u];
    &#125;
    <span class="hljs-keyword">return</span> ret;
&#125;</code></pre>



<h2 id="2-8-并查集"><a href="#2-8-并查集" class="headerlink" title="2.8 并查集"></a>2.8 并查集</h2><blockquote>
<p>1.合并两个集合</p>
<p>2.查询两个元素是否在同一个集合</p>
</blockquote>
<pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;

<span class="hljs-type">int</span> n, m;
<span class="hljs-type">int</span> p[N], len[N];

<span class="hljs-comment">//初始化</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i ++) p[i] = i, len[i] = <span class="hljs-number">1</span>;
&#125;

<span class="hljs-comment">//查</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;
    <span class="hljs-keyword">return</span> p[x] == x? x : p[x] = <span class="hljs-built_in">find</span>(p[x]);
&#125;

<span class="hljs-comment">//并</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;
    <span class="hljs-type">int</span> fx = <span class="hljs-built_in">find</span>(x);
    <span class="hljs-type">int</span> fy = <span class="hljs-built_in">find</span>(y);
    <span class="hljs-keyword">if</span> (fx == fy) <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">if</span> (len[fx] &lt; len[fy]) <span class="hljs-built_in">swap</span>(fx, fy);
    len[fx] += len[fy];
    p[fy] = fx;
&#125;</code></pre>

<h2 id="2-9-堆"><a href="#2-9-堆" class="headerlink" title="2.9 堆"></a>2.9 堆</h2><ol>
<li>插入x</li>
</ol>
<pre><code class="hljs cpp">
<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;
<span class="hljs-type">int</span> n, m;
<span class="hljs-type">int</span> h[N], len;

<span class="hljs-comment">//down</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">down</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;
    <span class="hljs-type">int</span> t = u;
    <span class="hljs-keyword">if</span> (<span class="hljs-number">2</span> * u &lt;= len &amp;&amp; h[<span class="hljs-number">2</span> * u] &lt; h[t]) t = <span class="hljs-number">2</span> * u;
    <span class="hljs-keyword">if</span> (<span class="hljs-number">2</span> * u + <span class="hljs-number">1</span> &lt;= len &amp;&amp; h[<span class="hljs-number">2</span> * u + <span class="hljs-number">1</span>] &lt; h[t]) t = <span class="hljs-number">2</span> * u + <span class="hljs-number">1</span>;
    <span class="hljs-keyword">if</span> (u != t)  &#123;
        <span class="hljs-built_in">swap</span>(h[u], h[t]);
        <span class="hljs-built_in">down</span>(t);
    &#125;
&#125;

<span class="hljs-comment">//up</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">up</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;
    <span class="hljs-type">int</span> t = u;
    <span class="hljs-keyword">while</span> (u / <span class="hljs-number">2</span> &amp;&amp; h[u / <span class="hljs-number">2</span>] &gt; h[u]) &#123;
        <span class="hljs-built_in">swap</span>(h[u / <span class="hljs-number">2</span>], h[u]);
        u /= <span class="hljs-number">2</span>;
    &#125;
&#125;</code></pre>





<h3 id="2-9-2-堆（双指向版"><a href="#2-9-2-堆（双指向版" class="headerlink" title="2.9.2 堆（双指向版)"></a>2.9.2 堆（双指向版)</h3><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;
<span class="hljs-type">int</span> n;
<span class="hljs-type">int</span> h[N], hp[N], ph[N], len;	<span class="hljs-comment">//ph：第i个插入的数在堆的哪个位置</span>
							<span class="hljs-comment">//hp: 堆的第i个位置是第几个插入的数</span>

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heap_swap</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;
    <span class="hljs-built_in">swap</span>(ph[hp[a]], ph[hp[b]]);
    <span class="hljs-built_in">swap</span>(hp[a], hp[b]);
    <span class="hljs-built_in">swap</span>(h[a], h[b]);
&#125;

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">down</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;
    <span class="hljs-type">int</span> t = u;
    <span class="hljs-keyword">if</span> (<span class="hljs-number">2</span> * u &lt;= len &amp;&amp; h[<span class="hljs-number">2</span> * u] &lt; h[t]) t = <span class="hljs-number">2</span> * u;
    <span class="hljs-keyword">if</span> (<span class="hljs-number">2</span> * u + <span class="hljs-number">1</span> &lt;= len &amp;&amp; h[<span class="hljs-number">2</span> * u + <span class="hljs-number">1</span>] &lt; h[t]) t = <span class="hljs-number">2</span> * u + <span class="hljs-number">1</span>;
    <span class="hljs-keyword">if</span> (u != t) &#123;
        <span class="hljs-built_in">heap_swap</span>(u, t);
        <span class="hljs-built_in">down</span>(t);
    &#125;
&#125;

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">up</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;
    <span class="hljs-keyword">while</span> (u &gt; <span class="hljs-number">1</span> &amp;&amp; h[u / <span class="hljs-number">2</span>] &gt; h[u]) &#123;
        <span class="hljs-built_in">heap_swap</span>(u / <span class="hljs-number">2</span>, u);
        u /= <span class="hljs-number">2</span>;
    &#125;
&#125;</code></pre>

<h2 id="3-哈希表"><a href="#3-哈希表" class="headerlink" title="3 哈希表"></a>3 哈希表</h2><h3 id="3-1-模拟散列表"><a href="#3-1-模拟散列表" class="headerlink" title="3.1 模拟散列表"></a>3.1 模拟散列表</h3><h4 id="3-1-1-拉链法"><a href="#3-1-1-拉链法" class="headerlink" title="3.1.1 拉链法"></a>3.1.1 拉链法</h4><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100003</span>;
<span class="hljs-type">int</span> n;
<span class="hljs-type">int</span> h[N], e[N], ne[N], idx;

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;
    <span class="hljs-type">int</span> k = (x % N + N) % N;
    e[idx] = x;
    ne[idx] = h[k];
    h[k] = idx ++;
&#125;

<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;
    <span class="hljs-type">int</span> k = (x % N + N) % N;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[k]; i != <span class="hljs-number">-1</span>; i = ne[i])
        <span class="hljs-keyword">if</span> (e[i] == x) 
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
&#125;</code></pre>





<h4 id="3-1-2-开放式寻址法"><a href="#3-1-2-开放式寻址法" class="headerlink" title="3.1.2 开放式寻址法"></a>3.1.2 开放式寻址法</h4><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">200003</span>, null = <span class="hljs-number">0x3f3f3f3f</span>;
<span class="hljs-type">int</span> n;
<span class="hljs-type">int</span> h[N];

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;
    <span class="hljs-type">int</span> k = (x % N + N) % N;
    <span class="hljs-keyword">while</span> (h[k] != null &amp;&amp; h[k] != x) &#123;
        k ++;
        <span class="hljs-keyword">if</span> (k == N) &#123;
            k = <span class="hljs-number">0</span>; 
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> k;
&#125;</code></pre>

<h3 id="3-2-字符串哈希-（字符串前缀哈希法）"><a href="#3-2-字符串哈希-（字符串前缀哈希法）" class="headerlink" title="3.2 字符串哈希 （字符串前缀哈希法）"></a>3.2 字符串哈希 （字符串前缀哈希法）</h3><p><strong>原理</strong>：将一个字符串看成一个P进制的数，将P进制数转换成十进制数，得到该字符串的哈希值。</p>
<p>例字：<code>ABCD</code>: A * P^3 + B * P^2 +  C * P^1 + D * P^0所得的十进制数就是该字符串的哈希值。</p>
<p>由于字符串可能很大，得到的数值会非常大，故对该数进行取模。由ULL溢出后自动取模做到这一步。取模后的数可能会由冲突，该算法的前提假设人品足够好，不考虑冲突的情况。</p>
<blockquote>
<ol>
<li><p>不能映射成0（如果<code>A</code>映射成0，那么<code>A</code>与<code>AA</code>、<code>AAA</code>将冲突</p>
</li>
<li><p>假设人品(Rp)足够好，假定不存在冲突</p>
</li>
</ol>
<p>经验值：p取131&#x2F;13331， Q取2^64</p>
</blockquote>
<p><strong>好处</strong>：利用前缀哈希，计算出任何字串的哈希值。</p>
<blockquote>
<p>求区间[l,r]的字串的哈希值：<br>由于左边是高位，右边是低位，需要最低位对其。将h[l - 1]右移与h[r]右对齐（最低位）对齐后，相减的差即为该区间字串的哈希值。（右移r - l + 1位需要乘上P^(r - l + 1)）</p>
</blockquote>
<pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ULL;
<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>, P = <span class="hljs-number">131</span>;

<span class="hljs-type">int</span> n, m;
<span class="hljs-type">char</span> s[N]; <span class="hljs-comment">//字符串数组，下标从1开始，方便处理</span>
ULL h[N], p[N];	<span class="hljs-comment">//h[N]字符串前缀哈希值，p[N] p的n次方数组（对ull取模后的值）</span>
<span class="hljs-comment">//求区间[l,r]的字串的哈希值：</span>
<span class="hljs-function">ULL <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;
    <span class="hljs-keyword">return</span> h[r] - h[l - <span class="hljs-number">1</span>] * p[r - l + <span class="hljs-number">1</span>];
&#125;

p[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;
<span class="hljs-comment">//求取字符串前缀哈希值、P的次方值（p数组存）</span>
<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) &#123;
    p[i] = p[i - <span class="hljs-number">1</span>] * P;
    h[i] = h[i - <span class="hljs-number">1</span>] * P + s[i];
&#125;</code></pre>





<h1 id="3-搜索与图论"><a href="#3-搜索与图论" class="headerlink" title="3. 搜索与图论"></a>3. 搜索与图论</h1><h2 id="3-1-DFS"><a href="#3-1-DFS" class="headerlink" title="3.1 DFS"></a>3.1 DFS</h2><h3 id="3-1-1-交换法"><a href="#3-1-1-交换法" class="headerlink" title="3.1.1 交换法"></a>3.1.1 交换法</h3><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">10</span>;
<span class="hljs-type">int</span> n;
<span class="hljs-type">int</span> a[N];

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;
    <span class="hljs-keyword">if</span> (u == n) &#123;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, a[i]);
        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);
    &#125;
    
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = u; i &lt; n; i ++) &#123;
        <span class="hljs-built_in">swap</span>(a[i], a[u]);
        <span class="hljs-built_in">dfs</span>(u + <span class="hljs-number">1</span>);
        <span class="hljs-built_in">swap</span>(a[i], a[u]);
    &#125;
&#125;</code></pre>

<h3 id="3-1-2-回溯法"><a href="#3-1-2-回溯法" class="headerlink" title="3.1.2 回溯法"></a>3.1.2 回溯法</h3><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">10</span>;
<span class="hljs-type">int</span> n;
<span class="hljs-type">int</span> a[N];
<span class="hljs-type">bool</span> vis[N];

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;
    <span class="hljs-keyword">if</span> (u == n) &#123;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, a[i]);
        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);
    &#125;
    
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) &#123;
        <span class="hljs-keyword">if</span> (vis[i]) <span class="hljs-keyword">continue</span>;
        vis[i] = <span class="hljs-literal">true</span>;
        a[u] = i + <span class="hljs-number">1</span>;
        <span class="hljs-built_in">dfs</span>(u + <span class="hljs-number">1</span>);
        vis[i] = <span class="hljs-literal">false</span>;
    &#125;
&#125;</code></pre>

<h3 id="3-1-3-n皇后问题-朴素解法"><a href="#3-1-3-n皇后问题-朴素解法" class="headerlink" title="3.1.3 n皇后问题 (朴素解法)"></a>3.1.3 n皇后问题 (朴素解法)</h3><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">20</span>;
<span class="hljs-type">int</span> n;
<span class="hljs-type">char</span> g[N][N];
<span class="hljs-type">int</span> col[N], dg[N], udg[N];

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;
    <span class="hljs-keyword">if</span> (u == n) &#123;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) <span class="hljs-built_in">puts</span>(g[i]);
        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);
        <span class="hljs-keyword">return</span>;
    &#125;
    
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)
        <span class="hljs-keyword">if</span> (!col[i] &amp;&amp; !dg[u + i] &amp;&amp; !udg[n - u + i]) &#123;
            g[u][i] = <span class="hljs-string">&#x27;Q&#x27;</span>;
            col[i] = dg[u + i] = udg[n - u + i] = <span class="hljs-literal">true</span>;
            <span class="hljs-built_in">dfs</span>(u + <span class="hljs-number">1</span>);
            col[i] = dg[u + i] = udg[n - u + i] = <span class="hljs-literal">false</span>;
            g[u][i] = <span class="hljs-string">&#x27;.&#x27;</span>;
        &#125;
&#125;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j ++)
            g[i][j] = <span class="hljs-string">&#x27;.&#x27;</span>;
            
    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>);
    
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;
</code></pre>

<h3 id="3-1-4-n皇后问题-位运算解法"><a href="#3-1-4-n皇后问题-位运算解法" class="headerlink" title="3.1.4 n皇后问题 (位运算解法)"></a>3.1.4 n皇后问题 (位运算解法)</h3><h2 id="3-2-BFS"><a href="#3-2-BFS" class="headerlink" title="3.2 BFS"></a>3.2 BFS</h2><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">110</span>;
<span class="hljs-type">int</span> q[N];

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-type">int</span> hh =<span class="hljs-number">0</span>,  tt = <span class="hljs-number">0</span>;
    q[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;
    
    <span class="hljs-keyword">while</span> (hh &lt;= tt) &#123;
        <span class="hljs-keyword">auto</span> t = q[hh ++];
        <span class="hljs-comment">//将t的周围加入队列q</span>
        <span class="hljs-comment">//...</span>
    &#125;
&#125;</code></pre>



<h2 id="3-3-树与图的DFS"><a href="#3-3-树与图的DFS" class="headerlink" title="3.3 树与图的DFS"></a>3.3 树与图的DFS</h2><h3 id="3-3-1-领接表"><a href="#3-3-1-领接表" class="headerlink" title="3.3.1 领接表"></a>3.3.1 领接表</h3><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>, M = N * <span class="hljs-number">2</span>;

<span class="hljs-type">int</span> h[N], e[M], ne[M], idx;

<span class="hljs-comment">//领接表加边a-&gt;b</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;
&#125;
</code></pre>

<pre><code class="hljs cpp"><span class="hljs-type">int</span> h[N], w[N], e[N], ne[N], idx;
<span class="hljs-comment">//add,a-&gt;b ，权重c</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span> </span>&#123;
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;
&#125;</code></pre>





<h3 id="3-3-2-深度优先遍历"><a href="#3-3-2-深度优先遍历" class="headerlink" title="3.3.2 深度优先遍历"></a>3.3.2 深度优先遍历</h3><pre><code class="hljs cpp"><span class="hljs-type">int</span> h[N], e[M], ne[M], idx;
<span class="hljs-type">int</span> vis[N];

<span class="hljs-comment">//树的dfs</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>
<span class="hljs-function"></span>&#123;
    vis[u] = <span class="hljs-literal">true</span>;
    
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[u]; i != <span class="hljs-number">-1</span>; i = ne[i]) 
    &#123;
        <span class="hljs-keyword">if</span> (!vis[e[i] ]) &#123;
            <span class="hljs-built_in">dfs</span>(e[i])
        &#125;
    &#125;
&#125;</code></pre>

<h2 id="3-4-树与图的BFS"><a href="#3-4-树与图的BFS" class="headerlink" title="3.4 树与图的BFS"></a>3.4 树与图的BFS</h2><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;

<span class="hljs-type">int</span> n, m;
<span class="hljs-type">int</span> h[N], e[N], ne[N], idx;
<span class="hljs-type">int</span> d[N], q[N];

<span class="hljs-comment">//add</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;
&#125;

<span class="hljs-comment">//bfs</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span>  </span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-type">int</span> hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">0</span>;
    d[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;
    q[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;
    
    <span class="hljs-keyword">while</span> (hh &lt;= tt) 
    &#123;
        <span class="hljs-type">int</span> t = q[hh ++];
        
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; i != <span class="hljs-number">-1</span>; i = ne[i]) &#123;
            <span class="hljs-type">int</span> j = e[i];
            <span class="hljs-keyword">if</span> (d[j] == <span class="hljs-number">-1</span>) &#123;
                d[j] = d[t] + <span class="hljs-number">1</span>;
                q[++ tt] = j;
            &#125;
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> d[n];
&#125;</code></pre>





<h2 id="3-5-拓扑排序"><a href="#3-5-拓扑排序" class="headerlink" title="3.5 拓扑排序"></a>3.5 拓扑排序</h2><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;

<span class="hljs-type">int</span> h[N], e[N], ne[N], idx;
<span class="hljs-type">int</span> d[N], q[N];

<span class="hljs-type">int</span> n, m;

<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">topsort</span><span class="hljs-params">()</span> </span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-type">int</span> hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">-1</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)
        <span class="hljs-keyword">if</span> (!d[i])
            q[++ tt] = i;
            
    <span class="hljs-keyword">while</span> (hh &lt;= tt) &#123;
        <span class="hljs-type">int</span> t = q[hh ++];
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; i != <span class="hljs-number">-1</span>; i = ne[i]) &#123;
            <span class="hljs-type">int</span> j = e[i];
            <span class="hljs-keyword">if</span> (-- d[j] == <span class="hljs-number">0</span>) 
                q[++ tt] = j;
        &#125;
    &#125;
    
    <span class="hljs-keyword">return</span> tt == n - <span class="hljs-number">1</span>;
&#125;</code></pre>



<h2 id="3-6-最短路"><a href="#3-6-最短路" class="headerlink" title="3.6 最短路"></a>3.6 最短路</h2><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" 
  class="img-loading" data-original="https://typoradrawingbed.oss-cn-guangzhou.aliyuncs.com/img/%E6%9C%80%E7%9F%AD%E8%B7%AF.png""></p>
<ol>
<li>单源最短路</li>
<li>多源汇最短路 ： 多个询问， 起点和终点的最短距离</li>
</ol>
<h3 id="3-6-1-Dijkstra（无负权边）"><a href="#3-6-1-Dijkstra（无负权边）" class="headerlink" title="3.6.1  Dijkstra（无负权边）"></a>3.6.1  Dijkstra（无负权边）</h3><p>n ：点数， m ： 边数</p>
<p>求两点之间的最短路，</p>
<blockquote>
<p><strong>前提条件</strong>：所有边都是正全权边（不存在负权边）</p>
</blockquote>
<h4 id="3-6-1-1-朴素Dijkstra"><a href="#3-6-1-1-朴素Dijkstra" class="headerlink" title="3.6.1.1 朴素Dijkstra"></a>3.6.1.1 朴素Dijkstra</h4><ol>
<li>初始化所有点的路径为无穷大，起点的路径修改为0</li>
<li>从未确定的点中，选取距离起点最近的点，将该点加入以确定的点的集合</li>
<li>用该点更新其他所有未确定的点距离</li>
<li>重复2-3，直到所有的点全部确定。</li>
</ol>
<blockquote>
<p>时间O(n ^ 2)， 适合稠密图</p>
</blockquote>
<pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>;

<span class="hljs-type">int</span> n, m;
<span class="hljs-type">int</span> g[N][N];	<span class="hljs-comment">//领接矩阵</span>
<span class="hljs-type">int</span> dist[N];	<span class="hljs-comment">//最短距离</span>
<span class="hljs-type">bool</span> st[N];		<span class="hljs-comment">//已确定的点集合</span>

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span> </span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-comment">//初始化</span>
    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);
    <span class="hljs-built_in">memset</span>(st, <span class="hljs-literal">false</span>, <span class="hljs-keyword">sizeof</span> st);
    
    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;
    
    <span class="hljs-comment">//循环n次， 确定n个点的最短距离</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) 
    &#123;
        <span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++)
            <span class="hljs-keyword">if</span> (!st[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || dist[t] &gt; dist[j]))
                t = j;
                
        st[t] = <span class="hljs-literal">true</span>; 
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++)
            dist[j] = <span class="hljs-built_in">min</span>(dist[j], dist[t] + g[t][j]);
    &#125;
    
    <span class="hljs-keyword">if</span> (dist[n] == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
    <span class="hljs-keyword">return</span> dist[n];
&#125;</code></pre>

<h4 id="3-6-1-2-堆优化Dijkstra"><a href="#3-6-1-2-堆优化Dijkstra" class="headerlink" title="3.6.1.2 堆优化Dijkstra"></a>3.6.1.2 堆优化Dijkstra</h4><blockquote>
<p>时间O(m * lgn)， 适合稀疏图</p>
</blockquote>
<p>思路：利用优先队列， 将查找未确定的、距离最短的点这一步时间复杂度优化到logn</p>
<ol>
<li>初始点的距离为0， 加入优先队列</li>
<li>取出队列里头结点（该点的距离为未确定的点中的最短距离）</li>
<li>如果该点已经确定， 回到2</li>
<li>更新该点到邻点的距离（假如更新后的点距离更短），并将邻点的距离加入优先队列</li>
<li>重复2-4， 直至队列为空</li>
</ol>
<pre><code class="hljs cpp"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">150010</span>;
<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;

<span class="hljs-type">int</span> n, m;
<span class="hljs-type">int</span> h[N], e[N], w[N], ne[N], idx;
<span class="hljs-type">int</span> dist[N];
<span class="hljs-type">int</span> st[N];

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span> <span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span> </span>&#123;
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;
&#125;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span> </span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);
    <span class="hljs-built_in">memset</span>(st, <span class="hljs-literal">false</span>, <span class="hljs-keyword">sizeof</span> st);
    
    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;
    
    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;
    heap.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;);
    
    <span class="hljs-keyword">while</span> (heap.<span class="hljs-built_in">size</span>() )
    &#123;
        <span class="hljs-keyword">auto</span> t = heap.<span class="hljs-built_in">top</span>(); heap.<span class="hljs-built_in">pop</span>();
        <span class="hljs-type">int</span> ver = t.second, distence = t.first;
        <span class="hljs-comment">//这个点已确定</span>
        <span class="hljs-keyword">if</span> (st[ver]) <span class="hljs-keyword">continue</span>;
        st[ver] = <span class="hljs-literal">true</span>;
        
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[ver]; i != <span class="hljs-number">-1</span>; i = ne[i]) &#123;
            <span class="hljs-type">int</span> j = e[i];
            <span class="hljs-keyword">if</span> (dist[j] &gt; dist[ver] + w[i]) &#123;
                dist[j] = dist[ver] + w[i];
                heap.<span class="hljs-built_in">push</span>(&#123;dist[j], j&#125;);
                <span class="hljs-comment">// cout &lt;&lt; dist[j] &lt;&lt; &#x27; &#x27;;</span>
            &#125;
        &#125;
    &#125;
    
    <span class="hljs-keyword">if</span> (dist[n] == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
    <span class="hljs-keyword">return</span> dist[n];
&#125;</code></pre>

<h3 id="3-6-2-带负权的最短路"><a href="#3-6-2-带负权的最短路" class="headerlink" title="3.6.2 带负权的最短路"></a>3.6.2 带负权的最短路</h3><h4 id="3-6-2-1-Bellman-Ford"><a href="#3-6-2-1-Bellman-Ford" class="headerlink" title="3.6.2.1 Bellman-Ford"></a>3.6.2.1 Bellman-Ford</h4><blockquote>
<p>O(n * m)</p>
</blockquote>
<pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>, M = <span class="hljs-number">10010</span>;

<span class="hljs-type">int</span> n, m, k;
<span class="hljs-type">int</span> dist[N], backup[N];

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;
    <span class="hljs-type">int</span> a, b, c;
&#125;edges[M];


<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bellman_ford</span><span class="hljs-params">()</span> </span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);
    
    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i ++) 
    &#123;
        <span class="hljs-built_in">memcpy</span>(backup, dist, <span class="hljs-keyword">sizeof</span> dist);
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j ++) 
        &#123;
            <span class="hljs-keyword">auto</span> [a, b, c] = edges[j];
            dist[b] = <span class="hljs-built_in">min</span>(dist[b], backup[a] + c);
        &#125;
    &#125;
        
    <span class="hljs-keyword">if</span> (dist[n] &gt; <span class="hljs-number">0x3f3f3f3f</span> / <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
    <span class="hljs-keyword">return</span> dist[n];
&#125;</code></pre>



<h4 id="3-6-2-2-SPFA求最短路"><a href="#3-6-2-2-SPFA求最短路" class="headerlink" title="3.6.2.2 SPFA求最短路"></a>3.6.2.2 SPFA求最短路</h4><blockquote>
<p>O(m)， 最坏O(nm)</p>
</blockquote>
<pre><code class="hljs cpp">
<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;

<span class="hljs-type">int</span> n, m;
<span class="hljs-type">int</span> h[N], e[N], w[N], ne[N], idx;
<span class="hljs-type">int</span> dist[N];
<span class="hljs-type">int</span> st[N];

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span> </span>&#123;
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;
&#125;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);
    
    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;
    
    queue&lt;<span class="hljs-type">int</span>&gt; q;
    q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);
    st[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;
    
    <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>() ) 
    &#123;
        <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();
        st[t] = <span class="hljs-literal">false</span>;
        
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; i != <span class="hljs-number">-1</span>; i = ne[i])
        &#123;
            <span class="hljs-type">int</span> j = e[i];
            <span class="hljs-keyword">if</span> (dist[j] &gt; dist[t] + w[i])
            &#123;
                dist[j] = dist[t] + w[i];
                <span class="hljs-keyword">if</span> (!st[j])
                &#123;
                    q.<span class="hljs-built_in">push</span>(j);
                    st[j] = <span class="hljs-literal">true</span>;
                &#125;
            &#125;
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> dist[n];
&#125;</code></pre>

<h4 id="3-6-2-3-SPFA判负环"><a href="#3-6-2-3-SPFA判负环" class="headerlink" title="3.6.2.3 SPFA判负环"></a>3.6.2.3 SPFA判负环</h4><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">10010</span>;

<span class="hljs-type">int</span> n, m;
<span class="hljs-type">int</span> h[N], e[N], w[N], ne[N], idx;
<span class="hljs-type">int</span> dist[N], cnt[N];
<span class="hljs-type">int</span> st[N];

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span> </span>&#123;
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;
&#125;

<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    queue&lt;<span class="hljs-type">int</span>&gt; q;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) &#123;
        q.<span class="hljs-built_in">push</span>(i);
        st[i] = <span class="hljs-literal">true</span>;
    &#125;
    
    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>() )
    &#123;
        <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();
        st[t] = <span class="hljs-literal">false</span>;
        
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; i != <span class="hljs-number">-1</span>; i = ne[i]) 
        &#123;
            <span class="hljs-type">int</span> j = e[i];
            <span class="hljs-keyword">if</span> (dist[j] &gt; dist[t] + w[i]) 
            &#123;
                dist[j] = dist[t] + w[i];
                cnt[j] = cnt[t] + <span class="hljs-number">1</span>;
                
                <span class="hljs-keyword">if</span> (cnt[j] &gt;= n) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
                
                <span class="hljs-keyword">if</span> (!st[j]) &#123;
                    q.<span class="hljs-built_in">push</span>(j);
                    st[j] = <span class="hljs-literal">true</span>;
                &#125;
            &#125;
        &#125;
    &#125;
    
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
&#125;
</code></pre>





<h2 id="3-7-多源汇最短路"><a href="#3-7-多源汇最短路" class="headerlink" title="3.7 多源汇最短路"></a>3.7 多源汇最短路</h2><h3 id="3-7-1-Floyd"><a href="#3-7-1-Floyd" class="headerlink" title="3.7.1 Floyd"></a>3.7.1 Floyd</h3><blockquote>
<p>O(n ^ 3)</p>
</blockquote>
<pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">210</span>, INF = <span class="hljs-number">1e9</span>;
<span class="hljs-type">int</span> n, m, k;
<span class="hljs-type">int</span> d[N][N];

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">floyd</span><span class="hljs-params">()</span> </span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= n; k ++)
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++)
                d[i][j] = <span class="hljs-built_in">min</span>(d[i][j], d[i][k] + d[k][j]);
&#125;</code></pre>

<h2 id="3-8-最小生成树"><a href="#3-8-最小生成树" class="headerlink" title="3.8 最小生成树"></a>3.8 最小生成树</h2><h3 id="3-8-1-普利姆算法（Prim）"><a href="#3-8-1-普利姆算法（Prim）" class="headerlink" title="3.8.1 普利姆算法（Prim）"></a>3.8.1 普利姆算法（Prim）</h3><h4 id="3-8-1-1-稠密图（朴素版Prim）"><a href="#3-8-1-1-稠密图（朴素版Prim）" class="headerlink" title="3.8.1.1 稠密图（朴素版Prim）"></a>3.8.1.1 稠密图（朴素版Prim）</h4><blockquote>
<p>O(n^2)</p>
</blockquote>
<p>思路：</p>
<ol>
<li>初始化所有点的距离为正无穷</li>
<li>每次找到离集合最近的点， 用该点更新其余所有点到集合的距离</li>
<li>将该点加入集合</li>
<li>重复第2-3步n次</li>
</ol>
<pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;

<span class="hljs-type">int</span> n, m; 
<span class="hljs-type">int</span> g[N][N];
<span class="hljs-type">int</span> dist[N];
<span class="hljs-type">bool</span> st[N];

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">prim</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);
    
    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)
    &#123;
        <span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++)
            <span class="hljs-keyword">if</span> (!st[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || dist[t] &gt; dist[j]))
                t = j;
        <span class="hljs-comment">//不是第一个点且距离是正无穷， 说明与集合没有边相连        </span>
        <span class="hljs-keyword">if</span> (i &amp;&amp; dist[t] == INF) <span class="hljs-keyword">return</span> INF;
        <span class="hljs-comment">// 第一个点时， 不用加权重</span>
        <span class="hljs-keyword">if</span> (i) res += dist[t];
        
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++)
            <span class="hljs-keyword">if</span> (!st[j] &amp;&amp; dist[j] &gt; g[t][j])
                dist[j] = g[t][j];
        
        st[t] = <span class="hljs-literal">true</span>;
    &#125;
    
    <span class="hljs-keyword">return</span> res;
&#125;</code></pre>

<h4 id="3-8-1-2-稀疏图-（堆优化版Prim）"><a href="#3-8-1-2-稀疏图-（堆优化版Prim）" class="headerlink" title="3.8.1.2 稀疏图 （堆优化版Prim）"></a>3.8.1.2 稀疏图 （堆优化版Prim）</h4><blockquote>
<p>O(m logn)</p>
</blockquote>
<pre><code class="hljs cpp"></code></pre>



<h3 id="3-8-2-克鲁斯卡尔算法（Kruskal）"><a href="#3-8-2-克鲁斯卡尔算法（Kruskal）" class="headerlink" title="3.8.2  克鲁斯卡尔算法（Kruskal）"></a>3.8.2  克鲁斯卡尔算法（Kruskal）</h3><blockquote>
<p>O(mlogm)</p>
</blockquote>
<ol>
<li>从小到大排序所有边	（O(mlogm)</li>
<li>枚举每条边， 假如a，b不连通， 将这条边加入集合里（选了这条边用以连通a,b)     (O(m))</li>
</ol>
<pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> tuple&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; TIII;

<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>,  M = <span class="hljs-number">200010</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;

<span class="hljs-type">int</span> n, m;
TIII g[M];
<span class="hljs-type">int</span> p[N];

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;
    <span class="hljs-keyword">return</span> p[x] == x ? x : p[x] = <span class="hljs-built_in">find</span>(p[x]);
&#125;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kruskal</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-built_in">sort</span>(g, g + m);
    <span class="hljs-comment">//初始化并查集</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) p[i] = i;
    
    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-comment">//最小生成树</span>
    <span class="hljs-type">int</span> num = n;    <span class="hljs-comment">//集合数量</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i ++)
    &#123;
        <span class="hljs-keyword">auto</span> [c, a, b] = g[i];
        a = <span class="hljs-built_in">find</span>(a), b = <span class="hljs-built_in">find</span>(b);
        <span class="hljs-comment">//如果a,b不连通， 连通a,b</span>
        <span class="hljs-keyword">if</span> (a != b)
        &#123;
            p[a] = b;
            res += c;
            num --;
        &#125;
    &#125;
    
    <span class="hljs-keyword">if</span> (num == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> res;
    <span class="hljs-keyword">return</span> INF;
&#125;</code></pre>



<h2 id="3-9-二分图"><a href="#3-9-二分图" class="headerlink" title="3.9 二分图"></a>3.9 二分图</h2><h3 id="3-9-1-判断二分图（染色法）"><a href="#3-9-1-判断二分图（染色法）" class="headerlink" title="3.9.1 判断二分图（染色法）"></a>3.9.1 判断二分图（染色法）</h3><ol>
<li>遍历所有点</li>
<li>如果该点未染色， dfs染色该点及后面的点</li>
<li>dfs过程中， 遇到未染色的点， dfs染色该点</li>
<li>dfs过程中， 遇到已染色的点。 该点的颜色和要染的颜色一样，不处理。 不一样则返回false，说明不是二分图</li>
</ol>
<pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>, M = <span class="hljs-number">200010</span>;

<span class="hljs-type">int</span> n, m;
<span class="hljs-type">int</span> h[N], e[M], ne[M], idx;
<span class="hljs-type">int</span> color[N];

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>
<span class="hljs-function"></span>&#123;
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;
&#125;

<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> c)</span></span>
<span class="hljs-function"></span>&#123;
    color[u] = c;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[u]; i != <span class="hljs-number">-1</span>; i = ne[i])
    &#123;
        <span class="hljs-type">int</span> j = e[i];
        <span class="hljs-keyword">if</span> (!color[j])
        &#123;
            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">dfs</span>(j, <span class="hljs-number">3</span> - c)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        &#125;
        <span class="hljs-keyword">if</span> (color[j] == c) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
&#125;

<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isb</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)
    	<span class="hljs-keyword">if</span> (!color[i])
        	<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">dfs</span>(i, <span class="hljs-number">1</span>)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
&#125;
</code></pre>



<h3 id="3-9-2-二分图最大匹配-（匈牙利算法）"><a href="#3-9-2-二分图最大匹配-（匈牙利算法）" class="headerlink" title="3.9.2 二分图最大匹配 （匈牙利算法）"></a>3.9.2 二分图最大匹配 （匈牙利算法）</h3><blockquote>
<p>O(n*m)</p>
</blockquote>
<p>思路：</p>
<ol>
<li>遍历所有点</li>
<li>find当前点的所有边，如果对点没有对象， 则找到一个匹配</li>
<li>如果有对象， 则find这个对象， 如果这个匹配的对象能找到另外的匹配。则当前点能与这个对点成匹配</li>
<li>两者都不符合， 则当前点无对象</li>
</ol>
<pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>, M = <span class="hljs-number">100010</span>;
<span class="hljs-type">int</span> n1, n2, m;
<span class="hljs-type">int</span> h[N], e[M], ne[M], idx;
<span class="hljs-type">int</span> match[N];
<span class="hljs-type">bool</span> st[N];

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>&#123;
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;
&#125;

<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[x]; i != <span class="hljs-number">-1</span>; i = ne[i])
    &#123;
        <span class="hljs-type">int</span> j = e[i];
        <span class="hljs-keyword">if</span> (!st[j])
        &#123;
            st[j] = <span class="hljs-literal">true</span>;
            <span class="hljs-keyword">if</span> (match[j] == <span class="hljs-number">0</span> || <span class="hljs-built_in">find</span>(match[j]))
            &#123;
                match[j] = x;
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            &#125;
        &#125;
        
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
&#125;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">xyl</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n1; i ++)
    &#123;
        <span class="hljs-built_in">memset</span>(st, <span class="hljs-literal">false</span>, <span class="hljs-keyword">sizeof</span> st);
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">find</span>(i)) res ++;
    &#125;
    <span class="hljs-keyword">return</span> res;
&#125;</code></pre>

<h1 id="4-数学知识"><a href="#4-数学知识" class="headerlink" title="4. 数学知识"></a>4. 数学知识</h1><h2 id="4-1-质数"><a href="#4-1-质数" class="headerlink" title="4.1 质数"></a>4.1 质数</h2><h3 id="4-1-1-试除法-判定质数"><a href="#4-1-1-试除法-判定质数" class="headerlink" title="4.1.1 试除法-判定质数"></a>4.1.1 试除法-判定质数</h3><blockquote>
<p>O(sqrt(n))</p>
</blockquote>
<pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_prime</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= x / i; i ++)
        <span class="hljs-keyword">if</span> (x % i == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
&#125;</code></pre>

<h3 id="4-1-2-试除法-分解质因数"><a href="#4-1-2-试除法-分解质因数" class="headerlink" title="4.1.2 试除法-分解质因数"></a>4.1.2 试除法-分解质因数</h3><blockquote>
<p>O(sqrt(n))</p>
</blockquote>
<pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">divised</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n / i; i ++)
    &#123;
        <span class="hljs-keyword">if</span> (n % i == <span class="hljs-number">0</span>)
        &#123;
           
            <span class="hljs-type">int</span> s = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">while</span> (n % i == <span class="hljs-number">0</span>)
            &#123;
                n /= i;
                s ++;
            &#125;
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>, i, s);
        &#125;
    &#125;
    
    <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>, n, <span class="hljs-number">1</span>);
    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);
&#125;</code></pre>

<h3 id="4-1-3-质数筛"><a href="#4-1-3-质数筛" class="headerlink" title="4.1.3 质数筛"></a>4.1.3 质数筛</h3><blockquote>
<p>埃氏筛法 O(nloglogn)</p>
<p>欧拉筛 O(n)</p>
</blockquote>
<h4 id="埃氏筛法"><a href="#埃氏筛法" class="headerlink" title="埃氏筛法"></a>埃氏筛法</h4><blockquote>
<p>对于每个质数， 都把以它为质因子的数筛去</p>
</blockquote>
<pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1000010</span>;
<span class="hljs-type">int</span> prime[N], cnt;
<span class="hljs-type">bool</span> st[N];

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_primes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i ++)
        <span class="hljs-keyword">if</span> (!st[i])
        &#123;
            prime[cnt ++] = i;
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + i; j &lt;= n; j += i)
                st[j] = <span class="hljs-literal">true</span>;
        &#125;
&#125;</code></pre>

<h4 id="欧拉筛"><a href="#欧拉筛" class="headerlink" title="欧拉筛"></a>欧拉筛</h4><blockquote>
<p>ps : pj 是 i 的最小质因子时， pj 也是 pj * i 的最小质因子！</p>
<p>根据这个条件就能保证每个合数只被最小质因子筛一次</p>
</blockquote>
<pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1000010</span>;
<span class="hljs-type">int</span> prime[N], cnt;
<span class="hljs-type">bool</span> st[N];

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_primes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i ++)
    &#123;
        <span class="hljs-keyword">if</span> (!st[i]) prime[cnt ++] = i;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; prime[j] &lt;= n / i; j ++)
        &#123;
            st[prime[j] * i] = <span class="hljs-literal">true</span>;
            <span class="hljs-keyword">if</span> (i % prime[j] == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;	<span class="hljs-comment">// 重</span>
        &#125;
    &#125;
&#125;</code></pre>

<h2 id="4-2-约数"><a href="#4-2-约数" class="headerlink" title="4.2 约数"></a>4.2 约数</h2><h3 id="4-2-1-试除法-求一个数的约数"><a href="#4-2-1-试除法-求一个数的约数" class="headerlink" title="4.2.1 试除法-求一个数的约数"></a>4.2.1 试除法-求一个数的约数</h3><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">get_divisors</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>
<span class="hljs-function"></span>&#123;
    vector&lt;<span class="hljs-type">int</span>&gt; res;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n / i; i ++)
    &#123;
        <span class="hljs-keyword">if</span> (n % i == <span class="hljs-number">0</span>)
        &#123;
            res.<span class="hljs-built_in">push_back</span>(i);
            <span class="hljs-keyword">if</span> (i != n / i) res.<span class="hljs-built_in">push_back</span>(n / i);
        &#125;
    &#125;
    
    <span class="hljs-built_in">sort</span>(res.<span class="hljs-built_in">begin</span>(), res.<span class="hljs-built_in">end</span>());
    <span class="hljs-keyword">return</span> res;
&#125;</code></pre>

<h3 id="4-2-2-约数个数"><a href="#4-2-2-约数个数" class="headerlink" title="4.2.2 约数个数"></a>4.2.2 约数个数</h3><blockquote>
<p>分解质因数后， 约数个数为所有质因数的指数+1的乘积</p>
</blockquote>
<pre><code class="hljs cpp"><span class="hljs-type">int</span> n;
<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);

unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; mp;
<span class="hljs-keyword">while</span> (n --)
&#123;
    <span class="hljs-type">int</span> x;
    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x);

    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= x / i; i ++)
        <span class="hljs-keyword">while</span> (x % i == <span class="hljs-number">0</span>)
        &#123;
            x /= i;
            mp[i] ++;
        &#125;
    <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">1</span>) mp[x] ++;
&#125;

LL res = <span class="hljs-number">1</span>;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [_x, v] : mp) res = res *(v + <span class="hljs-number">1</span>) % mod;</code></pre>



<h3 id="4-2-3-约数之和"><a href="#4-2-3-约数之和" class="headerlink" title="4.2.3 约数之和"></a>4.2.3 约数之和</h3><blockquote>
<p>所有约数可用质因数求出， 约数之和 &#x3D; (p1^0 * p1^1*…*p1^a) * (p2^0*…*p2^a) * (px^0*…*px^a)</p>
</blockquote>
<pre><code class="hljs cpp">unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; mp;
    <span class="hljs-keyword">while</span> (n --)
    &#123;
        <span class="hljs-type">int</span> x;
        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x);
        
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= x / i; i ++)
            <span class="hljs-keyword">while</span> (x % i == <span class="hljs-number">0</span>)
            &#123;
                x /= i;
                mp[i] ++;
            &#125;
            
        <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">1</span>) mp[x] ++;
    &#125;
    
    LL res = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [p, a] : mp)
    &#123;
        LL t = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">while</span> (a --) t = (t * p + <span class="hljs-number">1</span>) % mod;
        res = res * t % mod;
    &#125;</code></pre>



<h3 id="4-2-4-欧几里得算法"><a href="#4-2-4-欧几里得算法" class="headerlink" title="4.2.4 欧几里得算法"></a>4.2.4 欧几里得算法</h3><blockquote>
<p>gcd(a, b) &#x3D; gcd(b, a % b)</p>
</blockquote>
<pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">return</span> b ? <span class="hljs-built_in">gcd</span>(b, a % b) : a;
&#125;</code></pre>

<h2 id="4-3-欧拉函数"><a href="#4-3-欧拉函数" class="headerlink" title="4.3 欧拉函数"></a>4.3 欧拉函数</h2><h3 id="4-3-1-欧拉函数"><a href="#4-3-1-欧拉函数" class="headerlink" title="4.3.1 欧拉函数"></a>4.3.1 欧拉函数</h3><blockquote>
<p>n的欧拉函数：1-n中与n互质的数的个数</p>
<p>&#x3D; n (1 - 1 &#x2F; p1) ( 1 - 1 &#x2F; p2) (1 - 1 &#x2F; p3)…(1 - 1 &#x2F; pk)</p>
</blockquote>
<p>分解质因数， 假设质因数为p1 p2 p3 … pk:</p>
<ol>
<li>从1-n中去掉p1、p2、…pk的所有倍数</li>
<li>加上所有pi * pj 的倍数</li>
<li>减去所有pi * pj * pk的倍数</li>
<li>加上所有pi * pj * pk * pl的倍数</li>
<li>…</li>
<li>（根据容斥原理得到 &#x3D; n (1 - 1 &#x2F; p1) ( 1 - 1 &#x2F; p2) (1 - 1 &#x2F; p3)…(1 - 1 &#x2F; pk) ）</li>
</ol>
<pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">euler_phi</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;
    <span class="hljs-type">int</span> res = n;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n / i; i ++)
        <span class="hljs-keyword">if</span> (n % i == <span class="hljs-number">0</span>) &#123;
            <span class="hljs-keyword">while</span> (n % i == <span class="hljs-number">0</span>) n /= i; 
            res = res - (res / i);
        &#125;
    <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">1</span>) res = res - (res / n);
    <span class="hljs-keyword">return</span> res;
&#125;</code></pre>

<h3 id="4-3-2-筛法求欧拉函数"><a href="#4-3-2-筛法求欧拉函数" class="headerlink" title="4.3.2  筛法求欧拉函数"></a>4.3.2  筛法求欧拉函数</h3><pre><code class="hljs cpp"><span class="hljs-function">LL <span class="hljs-title">euler_shai</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>
<span class="hljs-function"></span>&#123;
    phi[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;
    
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i ++)
    &#123;
        <span class="hljs-keyword">if</span> (!st[i])
        &#123;
            phi[i] = i - <span class="hljs-number">1</span>;
            primes[cnt ++] = i;
        &#125;
        
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; primes[j] &lt;= n / i; j ++)
        &#123;
            <span class="hljs-keyword">auto</span> pj = primes[j];
            st[pj * i] = <span class="hljs-literal">true</span>;
            <span class="hljs-keyword">if</span> (i % pj == <span class="hljs-number">0</span>) &#123;
                phi[i * pj] = (LL)phi[i] * pj;
                <span class="hljs-keyword">break</span>;
            &#125;
            phi[i * pj] = (LL)phi[i] * phi[pj];
        &#125;
    &#125;
    
    LL res = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) res += phi[i];
    <span class="hljs-keyword">return</span> res;
&#125;</code></pre>



<h2 id="4-4-快速幂"><a href="#4-4-快速幂" class="headerlink" title="4.4 快速幂"></a>4.4 快速幂</h2><h3 id="4-4-1-快速幂"><a href="#4-4-1-快速幂" class="headerlink" title="4.4.1 快速幂"></a>4.4.1 快速幂</h3><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qmi</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> p)</span> </span>&#123;
    <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">while</span> (k) &#123;
        <span class="hljs-keyword">if</span> (k &amp; <span class="hljs-number">1</span>) res = (LL)res * a % p;
        k &gt;&gt;= <span class="hljs-number">1</span>;
        a = (LL)a * a % p;
    &#125;
    <span class="hljs-keyword">return</span> res;
&#125;</code></pre>



<h3 id="4-4-2-快速幂求逆元"><a href="#4-4-2-快速幂求逆元" class="headerlink" title="4.4.2 快速幂求逆元"></a>4.4.2 快速幂求逆元</h3><pre><code class="hljs cpp">
<span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qmi</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> p)</span> </span>&#123;
    <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">while</span> (k) &#123;
        <span class="hljs-keyword">if</span> (k &amp; <span class="hljs-number">1</span>) res = (LL) res * a % p;
        k &gt;&gt;= <span class="hljs-number">1</span>;
        a = (LL) a * a % p;
    &#125;
    <span class="hljs-keyword">return</span> res;
&#125;

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">niyuan</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;
    <span class="hljs-keyword">if</span> (a % p) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in">qmi</span>(a, p - <span class="hljs-number">2</span>, p));
    <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;impossible&quot;</span>);
&#125;</code></pre>



<h2 id="4-5-扩展欧几里得算法"><a href="#4-5-扩展欧几里得算法" class="headerlink" title="4.5 扩展欧几里得算法"></a>4.5 扩展欧几里得算法</h2><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">exgcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> &amp;x, <span class="hljs-type">int</span> &amp;y)</span> </span>&#123;
    <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>) &#123;
        x = <span class="hljs-number">1</span>, y = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">return</span> a;
    &#125;
    <span class="hljs-type">int</span> d =  <span class="hljs-built_in">exgcd</span>(b, a % b, y, x);
    y -= a / b * x;
    <span class="hljs-keyword">return</span> d;
&#125;</code></pre>

<h3 id="4-5-2-线性同余方程"><a href="#4-5-2-线性同余方程" class="headerlink" title="4.5.2 线性同余方程"></a>4.5.2 线性同余方程</h3><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">exgcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> &amp;x, <span class="hljs-type">int</span> &amp;y)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">if</span> (!b) &#123;
        x = <span class="hljs-number">1</span>, y = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">return</span> a;
    &#125;
    
    <span class="hljs-type">int</span> d = <span class="hljs-built_in">exgcd</span>(b, a % b, y, x);
    y -= a / b * x;
    <span class="hljs-keyword">return</span> d;
&#125;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-type">int</span> n;
    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);
    
    <span class="hljs-keyword">while</span> (n --)
    &#123;
        <span class="hljs-type">int</span> a, b, m;
        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;m);
        <span class="hljs-type">int</span> x, y;
        <span class="hljs-type">int</span> d = <span class="hljs-built_in">exgcd</span>(a, m, x, y);
        
        <span class="hljs-keyword">if</span> (b % d) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;impossible&quot;</span>);
        <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, (LL)x * (b / d) % m);
    &#125;
&#125;</code></pre>

<h1 id="5-动态规划"><a href="#5-动态规划" class="headerlink" title="5.动态规划"></a>5.动态规划</h1><h2 id="5-1-01背包"><a href="#5-1-01背包" class="headerlink" title="5.1 01背包"></a>5.1 01背包</h2><p>题目：有n个体积和价值分别为vi和wi的物品，求体积不超过m的最大价值</p>
<h3 id="01背包-朴素解法"><a href="#01背包-朴素解法" class="headerlink" title="01背包-朴素解法"></a>01背包-朴素解法</h3><ul>
<li><p>集合表示</p>
<ul>
<li><code>f[i][j]</code>:从前<code>i</code>个物品中挑选（每个只能选一次），  总体积不超过<code>j</code>的最大价值的所有集合。</li>
<li>Max 所有集合中最大的价值</li>
</ul>
</li>
<li><p>状态转移：</p>
<ul>
<li>不选第i个物品：<code>f[i][j] = f[i - 1][j]</code></li>
<li>选第i个物品：<code>f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i])</code>	<code>j &gt;= v[i]</code></li>
</ul>
</li>
</ul>
<pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;
<span class="hljs-type">int</span> n, m;
<span class="hljs-type">int</span> v[N], w[N], f[N][N];    

<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)   
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++) &#123;
        f[i][j] = f[i - <span class="hljs-number">1</span>][j];
        <span class="hljs-keyword">if</span> (j &gt;= v[i]) f[i][j] = <span class="hljs-built_in">max</span>(f[i][j], f[i - <span class="hljs-number">1</span>][j - v[i]] + w[i]);
    &#125;</code></pre>

<h3 id="01背包-滚动数组"><a href="#01背包-滚动数组" class="headerlink" title="01背包-滚动数组"></a>01背包-滚动数组</h3><p>朴素解法中使用二维数组，仔细思考当前i的状态只由i-1转移得来，跟i-2、i-3等状态无关，即当前层只与上一层的状态有关，这种情况就可以用滚动数组来优化空间复杂度。滚动数组即开一个<code>f[2][m]</code>的数组，将一维重复利用，达到记录当前状态和上一状态目的。</p>
<p>使用滚动数组优化原数组，只需在滚动维度下边&amp;1即可。当i为奇数时，&amp;1&#x3D;1；当i为偶数时，&amp;1&#x3D;0，使用位运算可以方便编码。</p>
<pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;
<span class="hljs-type">int</span> n, m;
<span class="hljs-type">int</span> f[<span class="hljs-number">2</span>][N];

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;
    cin &gt;&gt; n &gt;&gt; m;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) &#123;
        <span class="hljs-type">int</span> v, w;
        cin &gt;&gt; v &gt;&gt; w;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++) &#123;
                f[i &amp; <span class="hljs-number">1</span>][j] = f[i - <span class="hljs-number">1</span> &amp; <span class="hljs-number">1</span>][j];
                <span class="hljs-keyword">if</span> (j &gt;= v)
                    f[i &amp; <span class="hljs-number">1</span>][j] = <span class="hljs-built_in">max</span>(f[i &amp; <span class="hljs-number">1</span>][j], f[i - <span class="hljs-number">1</span> &amp; <span class="hljs-number">1</span>][j - v] + w);
            &#125;
    &#125;
    cout &lt;&lt; f[n &amp; <span class="hljs-number">1</span>][m];
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre>



<h3 id="01背包-一维优化"><a href="#01背包-一维优化" class="headerlink" title="01背包-一维优化"></a>01背包-一维优化</h3><p>从朴素解法到滚动数组解法，优化了空间复杂度。思考二维的更新，当前v只会更新到v + j，即对数组前面的数值是没有影响的。若只使用一维记录时， 当j从大到小遍历，数组右边已遍历的视为当前i的记录，未遍历的视为i-1的记录（左边），即可无干扰的对数组进行更新。</p>
<p>注意一维优化的核心是，必须从大到小遍历容积j更新f[j]（若从小到大遍历j， 则可能当前物品被使用多次，即f[j]被更新多次）。</p>
<pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;
<span class="hljs-type">int</span> n, m;
<span class="hljs-type">int</span> f[N];

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
    cin &gt;&gt; n &gt;&gt; m;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) &#123;
        <span class="hljs-type">int</span> v, w;  cin &gt;&gt; v &gt;&gt; w;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = m; j &gt;= v; j --)
            f[j] = <span class="hljs-built_in">max</span>(f[j], f[j - v] + w);
    &#125;
    cout &lt;&lt; f[m];
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre>

<h2 id="5-2-完全背包"><a href="#5-2-完全背包" class="headerlink" title="5.2 完全背包"></a>5.2 完全背包</h2><p>有 N 种物品和一个容量是 V 的背包，每种物品都有无限件可用。求不超过背包体积的最大价值</p>
<h3 id="完全背包朴素解法"><a href="#完全背包朴素解法" class="headerlink" title="完全背包朴素解法"></a>完全背包朴素解法</h3><p>集合表示：</p>
<ul>
<li><code>f[i][j]</code>: 前<code>i</code>个物品（每个可以无限选），  总体积不超过<code>j</code>的最大价值。</li>
<li>max：<code>f[i][j]</code>的所有集合中的最大价值</li>
</ul>
<p>状态转移：</p>
<ul>
<li><p><code>f[i][j] = f[i - 1][j]</code>：不选当前物品i</p>
</li>
<li><p><code>f[i][j] = max(f[i][j], f[i - 1][j - v[i] * k] + w[i] * k)</code>	<code>j &gt;= v[i] * k</code>：选当前物品i，且总体积不超过j的的最大价值</p>
</li>
</ul>
<blockquote>
<p><code>n^3</code>，超时</p>
</blockquote>
<pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;
<span class="hljs-type">int</span> n, m;
<span class="hljs-type">int</span> f[N][N];

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
    cin &gt;&gt; n &gt;&gt; m;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) &#123;
        <span class="hljs-type">int</span> v, w; cin &gt;&gt; v &gt;&gt; w;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++) &#123;
            f[i][j] = f[i - <span class="hljs-number">1</span>][j];
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k * v &lt;= j; k ++)
            	f[i][j] = <span class="hljs-built_in">max</span>(f[i][j], f[i - <span class="hljs-number">1</span>][j - v * k] + w * k);
        &#125;
    &#125;
    cout &lt;&lt; f[n][m];
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre>

<h3 id="完全背包-时间优化（去重复计算"><a href="#完全背包-时间优化（去重复计算" class="headerlink" title="完全背包-时间优化（去重复计算"></a>完全背包-时间优化（去重复计算</h3><p>当某个物品体积小，可以选取多件时，更大的体积也支持选取多件，这两者中间就产生了重复的计算。计算大体积时，次大体积的为最优解，故不用比较此次大体积以下的计算。</p>
<p>当计算<code>f[i][j</code>]时，由 <code>f[i][j] = max(f[i][j], f[i - 1][j - v[i] * k] + w[i] * k)</code>展开，可得如下：</p>
<p><code>f[i][j] = max(f[i-1][j], f[i-1][j-v] + w, f[i-1][j-2v]+2w, f[i-1][j-3v]+3w, ……, f[i-1][j-kv]+kw)</code></p>
<p><code>f[i][j-v] = max(f[i-1][j-v], f[i-1][j-2v] + w, f[i-1][j-3v] + 2w, ……, f[i-1][j-kv] + (k-1)w)</code></p>
<blockquote>
<p>状态转移：</p>
<p><code>f[i][j] = max(f[i-1][j],f[i][j-v[i]]+w[i] </code></p>
</blockquote>
<pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;
<span class="hljs-type">int</span> n, m;
<span class="hljs-type">int</span> f[N][N];

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
    cin &gt;&gt; n &gt;&gt; m;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) &#123;
        <span class="hljs-type">int</span> v, w;
        cin &gt;&gt; v &gt;&gt; w;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++) &#123;
            f[i][j] = f[i - <span class="hljs-number">1</span>][j];
            <span class="hljs-keyword">if</span> (j &gt;= v)
            f[i][j] = <span class="hljs-built_in">max</span>(f[i][j], f[i][j - v] + w);
        &#125;
    &#125;
    cout &lt;&lt; f[n][m];
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre>

<h3 id="完全背包-一维空间优化"><a href="#完全背包-一维空间优化" class="headerlink" title="完全背包-一维空间优化"></a>完全背包-一维空间优化</h3><p>当某些题目情况下内存限制，需要优化空间内存，完全背包可以使用一维数组来求解。</p>
<p><strong>理解思路1：</strong>完全背包的空间优化中，可以直接去掉一维的数组，来完成记录即可。</p>
<ul>
<li><code>f[i][j] = f[i - 1][j]</code>转换成<code>f[j]=f[j]</code>（省略不写）</li>
<li><code>f[i][j] = max(f[i][j], f[i][j - v] + w)</code>转换成<code>f[j]=f[j - v] + w</code>（省略不写）</li>
</ul>
<pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;
<span class="hljs-type">int</span> n, m;
<span class="hljs-type">int</span> f[N];

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
    cin &gt;&gt; n &gt;&gt; m;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) &#123;
        <span class="hljs-type">int</span> v, w;
        cin &gt;&gt; v &gt;&gt; w;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++) &#123;
            <span class="hljs-keyword">if</span> (j &gt;= v)
            f[j] = <span class="hljs-built_in">max</span>(f[j], f[j - v] + w);
        &#125;
    &#125;
    cout &lt;&lt; f[m];
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre>



<p><strong>理解思路2：</strong>01背包中的一维空间优化受限于每个物品只能选取一次，需要从大往小遍历体积，如若从小往大遍历，会造成物品重复选取。重复选取则正是完全背包符合的，重复的次数从0到无限次，符合完全背包的题目需求。所以只需要将01背包的思路反向遍历一次即可。</p>
<pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;
<span class="hljs-type">int</span> n, m;
<span class="hljs-type">int</span> f[N];

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
    cin &gt;&gt; n &gt;&gt; m;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) &#123;
        <span class="hljs-type">int</span> v, w;
        cin &gt;&gt; v &gt;&gt; w;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = v; j &lt;= m; j ++)
            f[j] = <span class="hljs-built_in">max</span>(f[j], f[j - v] + w);
    &#125; 
    
    cout &lt;&lt; f[m];
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre>

<h2 id="5-3-多重背包"><a href="#5-3-多重背包" class="headerlink" title="5.3 多重背包"></a>5.3 多重背包</h2><p>有 N种物品和一个容量是 V 的背包。第 i 种物品最多有 si 件，每件体积是 vi，价值是 wi。求使物品体积总和不超过背包容量的最大价值。</p>
<h3 id="01背包思路"><a href="#01背包思路" class="headerlink" title="01背包思路"></a>01背包思路</h3><p>第i种物品最多有si件，可以看成01背包中的si件相同的物品，这样即可套用01背包的思路和代码来解</p>
<pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">110</span>;
<span class="hljs-type">int</span> n, m;
<span class="hljs-type">int</span> f[N];

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
    cin &gt;&gt; n &gt;&gt; m;
    <span class="hljs-keyword">while</span> (n --) &#123;
        <span class="hljs-type">int</span> v, w, s;
        cin &gt;&gt; v &gt;&gt; w &gt;&gt; s;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= s; i ++)
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = m; j &gt;= v; j --)
                f[j] = <span class="hljs-built_in">max</span>(f[j], f[j - v] + w);
    &#125;
    
    cout &lt;&lt; f[m];
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre>



<h3 id="完全背包思路"><a href="#完全背包思路" class="headerlink" title="完全背包思路"></a>完全背包思路</h3><p>可以将多重背包当成完全背包来推，只是每个i物品的数量k有限制。</p>
<p>集合表示：</p>
<ul>
<li><code>f[i][j]</code>: 前<code>i</code>个物品（每个可以无限选），  总体积不超过<code>j</code>的最大价值。</li>
<li>max：<code>f[i][j]</code>的所有集合中的最大价值</li>
</ul>
<p>状态转移：</p>
<ul>
<li><code>f[i][j] = f[i - 1][j]</code>：不选当前物品i</li>
<li><code>f[i][j] = max(f[i - 1][j], f[i - 1][j - v[i]*k] + w[i] * k)</code>	<code>j &gt;= v[i] * k &amp;&amp; k &lt;= s</code> ：选当前物品i，且总体积不超过j，数量不超过s的最大价值</li>
</ul>
<pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">110</span>;
<span class="hljs-type">int</span> f[N][N];
<span class="hljs-type">int</span> n, m;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    cin &gt;&gt; n &gt;&gt; m;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) &#123;
        <span class="hljs-type">int</span> v, w, s;
        cin &gt;&gt; v &gt;&gt; w &gt;&gt; s;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++) &#123;
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k * v &lt;= j &amp;&amp; k &lt;= s; k ++) 
                f[i][j] = <span class="hljs-built_in">max</span>(f[i][j], f[i - <span class="hljs-number">1</span>][j - v * k] + w * k);
        &#125;
    &#125;
    
    cout &lt;&lt; f[n][m];
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre>

<h3 id="二进制优化"><a href="#二进制优化" class="headerlink" title="二进制优化"></a>二进制优化</h3><p>物品i有数量si个时，可选的数量区间为[0,s]，物品i对最优解的贡献数量一定位于该闭区间内。是否存在一种数学优化，使得枚举该区间的所有数量值的复杂度优于O(n)？答案是使用二进制枚举。</p>
<p>将s个物品拆分成1，2，4，8，2^k，·······，c个，且1+2+4+8+<code>2^k</code>的和为s，可证明[0,s]区间内的所有数都可由这些数相加组成，将原有的n个数转化为logn个数的，再运用01背包思路求解这些数，可求出所有体积下应选该物品的数量和最大价值，时间复杂度将每个物品的O(n)优化到O(logn)。运用该二进制优化到所有的物品中，即可将多重背包转化成优化的01背包问题。套用01背包求解，即可得出答案。</p>
<p>难点：理解二进制优化的思想，为什么可以使用二进制优化？</p>
<p>代码一：将每个物品分割都记录下来，和思路一样。</p>
<pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">15000</span>, M = <span class="hljs-number">2010</span>;
<span class="hljs-type">int</span> n, m;
<span class="hljs-type">int</span> v[N], w[N];
<span class="hljs-type">int</span> f[M];

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    cin &gt;&gt; n &gt;&gt; m;
    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span> (n --) &#123;
        <span class="hljs-type">int</span> a, b, s;
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; s;
        <span class="hljs-type">int</span> k = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">while</span> (k &lt;= s) &#123;
            cnt ++;
            v[cnt] = a * k;
            w[cnt] = b * k;
            s -= k;
            k &lt;&lt;= <span class="hljs-number">1</span>;
        &#125;
        <span class="hljs-keyword">if</span> (s &gt; <span class="hljs-number">0</span>) &#123;
            cnt ++;
            v[cnt] = a * s;
            w[cnt] = b * s;
        &#125;
    &#125;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= cnt; i ++)
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = m; j &gt;= v[i]; j --)
            f[j] = <span class="hljs-built_in">max</span>(f[j], f[j - v[i]] + w[i]);
    
    cout &lt;&lt; f[m];
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre>

<p>代码二：将物品的每个分割不做记录直接计算，省一点空间，但比较绕一丢丢，需要深刻理解01背包。</p>
<pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2010</span>;
<span class="hljs-type">int</span> n, m;
<span class="hljs-type">int</span> f[N];

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
    cin &gt;&gt; n &gt;&gt; m;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) &#123;
        <span class="hljs-type">int</span> v, w, s; cin &gt;&gt; v &gt;&gt; w &gt;&gt; s;
        <span class="hljs-type">int</span> k = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">while</span> (k &lt;= s) &#123;
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = m; j &gt;= v * k; j --)
                f[j] = <span class="hljs-built_in">max</span>(f[j], f[j - v * k] + w * k);
            s -= k;
            k &lt;&lt;= <span class="hljs-number">1</span>;
        &#125;
        <span class="hljs-keyword">if</span> (s) <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = m;  j &gt;= v * s; j --)
                    f[j] = <span class="hljs-built_in">max</span>(f[j], f[j - v * s] + w * s);
    &#125;
    cout &lt;&lt; f[m];
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre>

<h3 id="单调队列优化"><a href="#单调队列优化" class="headerlink" title="单调队列优化"></a>单调队列优化</h3><p>当计算<code>f[i][j</code>]时，由 <code>f[i][j] = max(f[i][j], f[i - 1][j - v * s] + w * s)</code>展开，可得如下：</p>
<p><code>f[i][j] = max(f[i-1][j], f[i-1][j-v] + w, f[i-1][j-2v]+2w, f[i-1][j-3v]+3w, ……, f[i-1][j-sv]+sw)</code></p>
<p><code>f[i][j-v] = max(f[i-1][j-v], f[i-1][j-2v] + w, f[i-1][j-3v] + 2w, ……, f[i-1][j-(s + 1)v] + sw)</code></p>
<p>再求取<code>f[i][j-v]</code>时，可以使用单调队列维护<code>f[i][j-v]</code>使得查找该过程的复杂度为O(1)，</p>
<pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">20010</span>;
<span class="hljs-type">int</span> n, m;
<span class="hljs-type">int</span> f[N], g[N], q[N];

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>&#123;
    cin &gt;&gt; n &gt;&gt; m;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) &#123;
        <span class="hljs-type">int</span> v, w, s; cin &gt;&gt; v &gt;&gt; w &gt;&gt; s;
        <span class="hljs-built_in">memcpy</span>(g, f, <span class="hljs-keyword">sizeof</span> f);
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; v; j ++) &#123;
            <span class="hljs-type">int</span> hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">-1</span>;
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = j; k &lt;= m; k += v) &#123;
                <span class="hljs-keyword">while</span> (hh &lt;= tt &amp;&amp; q[hh] &lt; k - s * v) hh ++;
                <span class="hljs-keyword">if</span> (hh &lt;= tt) f[k] = <span class="hljs-built_in">max</span>(f[k], g[q[hh]] + (k - q[hh]) / v * w);
                <span class="hljs-keyword">while</span> (hh &lt;= tt &amp;&amp; g[q[tt]] - (q[tt] - j) / v * w &lt;= g[k] - (k - j) / v * w) tt --;
                q[++ tt] = k;
            &#125;
        &#125;
    &#125;
    cout &lt;&lt; f[m] &lt;&lt; endl;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre>



<h2 id="5-4-分组背包"><a href="#5-4-分组背包" class="headerlink" title="5.4 分组背包"></a>5.4 分组背包</h2><p>分组背包解决的是有n组，每组最多选一个物品，装进总容量为V的背包中，求最大价值。</p>
<p>状态表示：</p>
<ul>
<li>集合：<code>f[i][j]</code>：前i组背包中选，总体积不超过j的最大价值</li>
<li>属性：Max</li>
</ul>
<p>状态计算：</p>
<ul>
<li><code>f[i][j]</code> &#x3D; <code>max(f[i][j], f[i - 1][j])</code>：当前i组不选</li>
<li><code>f[i][j]</code>&#x3D; <code>max(f[i - 1][j], max(f[i - 1][j - vk] + wk))</code>：当前i组选第i个</li>
</ul>
<blockquote>
<p>注意分组背包的题目中，要把物品输入用数组记录下来，不能一边输入一边计算，因为容量的遍历要在分组背包前。否则就是01背包不是分组背包了</p>
</blockquote>
<pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">110</span>;
<span class="hljs-type">int</span> n, m;
<span class="hljs-type">int</span> v[N][N], w[N][N], s[N];
<span class="hljs-type">int</span> f[N];

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    cin &gt;&gt; n &gt;&gt; m;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) &#123;
        cin &gt;&gt; s[i];
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= s[i]; j ++) &#123;
            cin &gt;&gt; v[i][j] &gt;&gt; w[i][j];
        &#125;
    &#125;
    
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) 
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = m; j &gt;= <span class="hljs-number">0</span>; j --) 
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= s[i]; k ++)
                <span class="hljs-keyword">if</span> (j &gt;= v[i][k])
                    f[j] = <span class="hljs-built_in">max</span>(f[j], f[j - v[i][k]] + w[i][k]);
    
    cout &lt;&lt; f[m];
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre>

<h2 id="5-5-最长上升子序列"><a href="#5-5-最长上升子序列" class="headerlink" title="5.5 最长上升子序列"></a>5.5 最长上升子序列</h2><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;
<span class="hljs-type">int</span> n;
<span class="hljs-type">int</span> a[N], f[N];

<span class="hljs-comment">/*</span>
<span class="hljs-comment">f[i] = max(f[i], f[j] + 1) (a[i] &gt; a[j])</span>
<span class="hljs-comment">*/</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]);
    
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)
    &#123;
        f[i] = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; i; j ++)
            <span class="hljs-keyword">if</span> (a[i] &gt; a[j])
                f[i] = <span class="hljs-built_in">max</span>(f[i], f[j] + <span class="hljs-number">1</span>);
    &#125;
    
    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)
        res = <span class="hljs-built_in">max</span>(res, f[i]);
        
    cout &lt;&lt; res;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre>



<p><strong>n log n</strong>：</p>
<p>单调优化：即f[i]为0~i中最长上升子序列的最小增长序列</p>
<pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;
<span class="hljs-type">int</span> a[N];
<span class="hljs-type">int</span> q[N];
<span class="hljs-type">int</span> n;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);
    
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]);
    
    
    q[<span class="hljs-number">0</span>] = <span class="hljs-number">-2e9</span>;
    <span class="hljs-type">int</span> len = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)
    &#123;
        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = len;
        <span class="hljs-keyword">while</span> (l &lt; r) &#123;
            <span class="hljs-type">int</span> mid = l + (r - l + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;
            <span class="hljs-keyword">if</span> (q[mid] &lt; a[i]) l = mid;
            <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;
        &#125;
        
        len = <span class="hljs-built_in">max</span>(len, r + <span class="hljs-number">1</span>);
        q[r + <span class="hljs-number">1</span>] = a[i];
    &#125;
    
    cout &lt;&lt; len &lt;&lt; endl;
    
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre>



<h2 id="5-6-最长公共子序列"><a href="#5-6-最长公共子序列" class="headerlink" title="5.6 最长公共子序列"></a>5.6 最长公共子序列</h2><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;
<span class="hljs-type">int</span> n, m;
<span class="hljs-type">char</span> a[N], b[N];
<span class="hljs-type">int</span> f[N][N];

<span class="hljs-comment">/*</span>
<span class="hljs-comment">f[i][j] = max(f[i - 1][j], f[i][j - 1], f[i - 1][j - 1] + 1)</span>
<span class="hljs-comment">*/</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);
    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s%s&quot;</span>, a + <span class="hljs-number">1</span>, b + <span class="hljs-number">1</span>);
    
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++) &#123;
            f[i][j] = <span class="hljs-built_in">max</span>(f[i - <span class="hljs-number">1</span>][j], f[i][j - <span class="hljs-number">1</span>]);
            <span class="hljs-keyword">if</span> (a[i] == b[j]) f[i][j] = <span class="hljs-built_in">max</span>(f[i][j], f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);
        &#125;
        
    cout &lt;&lt; f[n][m];
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre>

<h2 id="5-7-区间DP-石子合并"><a href="#5-7-区间DP-石子合并" class="headerlink" title="5.7 区间DP-石子合并"></a>5.7 区间DP-石子合并</h2><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">310</span>;
<span class="hljs-type">int</span> s[N];
<span class="hljs-type">int</span> f[N][N];

<span class="hljs-comment">/*</span>
<span class="hljs-comment">f[i][j] = min(f[i][k] + f[k + 1][j] + s[j] - s[i - 1]);</span>
<span class="hljs-comment">*/</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-type">int</span> n;
    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;s[i]);
    
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) s[i] += s[i - <span class="hljs-number">1</span>];
    
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> len = <span class="hljs-number">2</span>; len &lt;= n; len ++) 
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i + len - <span class="hljs-number">1</span> &lt;= n; i ++) &#123;
            <span class="hljs-type">int</span> l = i, r = i + len - <span class="hljs-number">1</span>;
            f[l][r] = <span class="hljs-number">1e9</span>;
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = l;  k &lt; r; k ++)
                f[l][r] = <span class="hljs-built_in">min</span>(f[l][r], f[l][k] + f[k + <span class="hljs-number">1</span>][r] + s[r] - s[l - <span class="hljs-number">1</span>]);
        &#125;
        
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, f[<span class="hljs-number">1</span>][n]);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre>

<h2 id="5-8-计数DP"><a href="#5-8-计数DP" class="headerlink" title="5.8 计数DP"></a>5.8 计数DP</h2><p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/340/">计数问题</a></p>
<p>求某个区间内的所有数字上0-9出现的次数。</p>
<p>考虑 abcdefg 中第四位上1出现的次数</p>
<ol>
<li>如果前三位 &#x3D; 0~abc-1, 那1的次数是： abc * 1000 （加入x &#x3D; 0 时要从001开始，所以是 (abc -1) * 1000)</li>
<li>如果前三位 &#x3D; abc：<ol>
<li>d &lt; 1, 那么无论后面efg取什么，都是不符合：0</li>
<li>d &#x3D; 1, 后三位可取0~efg：efg+1</li>
<li>d &gt; 1, 后三位可取0~999：1000</li>
</ol>
</li>
</ol>
<pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;v, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;
    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = r; i &gt;= l; i --)
        res = res * <span class="hljs-number">10</span> + v[i];
    <span class="hljs-keyword">return</span> res;
&#125;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">power10</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> </span>&#123;
    <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">while</span> (i --) res *= <span class="hljs-number">10</span>;
    <span class="hljs-keyword">return</span> res;
&#125;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">count</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> x)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">if</span> (!n) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    
    vector&lt;<span class="hljs-type">int</span>&gt; v;
    <span class="hljs-keyword">for</span> (; n; n /= <span class="hljs-number">10</span>)
        v.<span class="hljs-built_in">push_back</span>(n % <span class="hljs-number">10</span>);
    
    n = v.<span class="hljs-built_in">size</span>();
    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span> - !x; i &gt;= <span class="hljs-number">0</span>; i --)
    &#123;
        <span class="hljs-keyword">if</span> (i &lt; n - <span class="hljs-number">1</span>) &#123;
            res += <span class="hljs-built_in">get</span>(v, i + <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>) * <span class="hljs-built_in">power10</span>(i);
            <span class="hljs-keyword">if</span> (!x) res -= <span class="hljs-built_in">power10</span>(i);
        &#125;
        <span class="hljs-comment">// cout &lt;&lt;&quot;--&quot; &lt;&lt; res &lt;&lt; endl;</span>
        <span class="hljs-keyword">if</span> (v[i] == x) res += <span class="hljs-built_in">get</span>(v, <span class="hljs-number">0</span>, i - <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (v[i] &gt; x) res += <span class="hljs-built_in">power10</span>(i);
        <span class="hljs-comment">// cout &lt;&lt; &quot;--&quot; &lt;&lt; res &lt;&lt; endl;</span>
    &#125;
    <span class="hljs-keyword">return</span> res;
&#125;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-type">int</span> a, b;
    <span class="hljs-keyword">while</span> (cin &gt;&gt; a &gt;&gt; b, a || b)
    &#123;
        <span class="hljs-keyword">if</span> (a &gt; b) <span class="hljs-built_in">swap</span>(a, b);
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i ++)
            cout &lt;&lt; <span class="hljs-built_in">count</span>(b, i) - <span class="hljs-built_in">count</span>(a - <span class="hljs-number">1</span>, i) &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;
        cout &lt;&lt; endl;
    &#125;
    
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;
</code></pre>







<h2 id="5-9-状态压缩"><a href="#5-9-状态压缩" class="headerlink" title="5.9 状态压缩"></a>5.9 状态压缩</h2><p>状态压缩，将某一状态用二进制01表示，用十进制存储，从而可以快速利用与或非等位运算，优化时空复杂度。</p>
<p>状态压缩通常会在题目上给出范围，当数据范围小时，就可以考虑是否能运用状态压缩</p>
<p>例题：</p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/293/"><strong>蒙德里安的梦想</strong></a></p>
<p>核心：<strong>先放横着的，再放竖着的</strong>。总的方案数等于合法的放置横着的方案数。</p>
<p>怎么判断横着的方案是否合法？所有列的竖着的连续空格是偶数个，才是合法</p>
<p>可以预处理一些状态，优化时间复杂度</p>
<pre><code class="hljs cpp"><span class="hljs-comment">/*</span>
<span class="hljs-comment">f[i][j]表示i-1列的横着放着的长方形伸到i列的状态为j的合法方案数</span>
<span class="hljs-comment">f[i][j] = sum(f[i-1][k]) (k &amp; j == 0 &amp;&amp; state[k|j])</span>
<span class="hljs-comment">*/</span>

<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>  LL;
<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">12</span>, M = <span class="hljs-number">1</span> &lt;&lt; N;
<span class="hljs-type">int</span> n, m;
LL f[N][M];
vector&lt;<span class="hljs-type">int</span>&gt; state[M];
<span class="hljs-type">bool</span> st[M];

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">while</span> (cin &gt;&gt; n &gt;&gt; m, n || m) &#123;
        <span class="hljs-comment">//预处理st：能否合法放置的列</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1</span> &lt;&lt; n; i ++)
        &#123;
            <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>, is_vaild = <span class="hljs-literal">true</span>;
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j ++)
            &#123;
                <span class="hljs-keyword">if</span> ((i &gt;&gt; j) &amp; <span class="hljs-number">1</span>) &#123;
                    <span class="hljs-keyword">if</span> (cnt &amp; <span class="hljs-number">1</span>) &#123; is_vaild = <span class="hljs-literal">false</span>; <span class="hljs-keyword">break</span>; &#125;
                    cnt = <span class="hljs-number">0</span>;
                &#125; <span class="hljs-keyword">else</span> cnt ++;
            &#125;
            <span class="hljs-keyword">if</span> (cnt &amp; <span class="hljs-number">1</span>) is_vaild = <span class="hljs-literal">false</span>;
            st[i] = is_vaild;
            <span class="hljs-comment">// cout &lt;&lt; st[i] &lt;&lt; &quot; &quot;;</span>
        &#125;
        
        <span class="hljs-comment">//预处理两列伸出不重叠冲突</span>
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1</span> &lt;&lt; n; i ++)
        &#123;
            state[i].<span class="hljs-built_in">clear</span>();
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">1</span> &lt;&lt; n; j ++)
            &#123;
                <span class="hljs-keyword">if</span> ((i &amp; j) == <span class="hljs-number">0</span> &amp;&amp; st[i | j])
                state[i].<span class="hljs-built_in">push_back</span>(j);
            &#125;
            <span class="hljs-comment">// cout &lt;&lt; state[i].size() &lt;&lt; endl;</span>
        &#125;
        
        <span class="hljs-built_in">memset</span>(f, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> f);
        <span class="hljs-comment">//dp</span>
        f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i ++)
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">1</span> &lt;&lt; n; j ++)
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> k : state[j])
                    f[i][j] += f[i - <span class="hljs-number">1</span>][k];
                    
        cout &lt;&lt; f[m][<span class="hljs-number">0</span>] &lt;&lt; endl;
    &#125;
&#125;</code></pre>

<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/93/"><strong>最短Hamilton路径</strong></a></p>
<pre><code class="hljs cpp"><span class="hljs-comment">/*</span>
<span class="hljs-comment">状态表示：f[i][j]:从0走到j点的路径经过的点集合为i的所有路径最短的长度</span>
<span class="hljs-comment">状态转移：f[i][j] = min(f[i-(j)][k]) + w[k][j], 枚举倒数第二个点k，表示从0走到k的点最小路径长度，再从k走到j点</span>
<span class="hljs-comment">*/</span>

<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">21</span>, M = <span class="hljs-number">1</span> &lt;&lt; N;
<span class="hljs-type">int</span> n;
<span class="hljs-type">int</span> w[N][N];
<span class="hljs-type">int</span> f[M][N];

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    cin &gt;&gt; n;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j ++)
            cin &gt;&gt; w[i][j];
    
    <span class="hljs-built_in">memset</span>(f, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> f);
    f[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1</span> &lt;&lt; n; i ++)
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j ++)
            <span class="hljs-keyword">if</span> (i &gt;&gt; j &amp; <span class="hljs-number">1</span>)
                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; n; k ++)
                    <span class="hljs-keyword">if</span> (i - (<span class="hljs-number">1</span> &lt;&lt; j) &gt;&gt; k &amp; <span class="hljs-number">1</span>)
                        f[i][j] = <span class="hljs-built_in">min</span>(f[i][j], f[i - (<span class="hljs-number">1</span> &lt;&lt; j)][k] + w[k][j]);
                        
    cout &lt;&lt; f[(<span class="hljs-number">1</span> &lt;&lt; n) - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre>

<h2 id="5-10-树形DP"><a href="#5-10-树形DP" class="headerlink" title="5.10 树形DP"></a>5.10 树形DP</h2><p> 解决的是树形结构的问题：通过子树的状态，转移到当前树的状态</p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/287/"><strong>没有上司的舞会</strong></a></p>
<pre><code class="hljs cpp"><span class="hljs-comment">/*</span>
<span class="hljs-comment">f[u][0]:表示以u为根节点的子树，不选u的最大值</span>
<span class="hljs-comment">f[u][1]:表示以u为根节点的子树，选u的最大值</span>
<span class="hljs-comment"></span>
<span class="hljs-comment">f[u][0] = sum(max(f[j][0], f[j][1])): 	j为u的子节点</span>
<span class="hljs-comment">f[u][1] = happy[u] + sum(f[j][0]):		j为u的子节点</span>
<span class="hljs-comment">*/</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">6010</span>;
<span class="hljs-type">int</span> n;
<span class="hljs-type">int</span> happy[N];
<span class="hljs-type">int</span> h[N], e[N], ne[N], idx;
<span class="hljs-type">int</span> f[N][<span class="hljs-number">2</span>];
<span class="hljs-type">bool</span> has_fat[N];


<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;
&#125;


<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>
<span class="hljs-function"></span>&#123;
    f[u][<span class="hljs-number">1</span>] = happy[u];
    
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[u]; i != <span class="hljs-number">-1</span>; i = ne[i]) &#123;
        <span class="hljs-type">int</span> j = e[i];
        <span class="hljs-built_in">dfs</span>(j);
        f[u][<span class="hljs-number">1</span>] += f[j][<span class="hljs-number">0</span>];
        f[u][<span class="hljs-number">0</span>] += <span class="hljs-built_in">max</span>(f[j][<span class="hljs-number">0</span>], f[j][<span class="hljs-number">1</span>]);
    &#125;
&#125;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;happy[i]);
    
    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i ++)
    &#123;
        <span class="hljs-type">int</span> a, b;
        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);
        has_fat[a] = <span class="hljs-literal">true</span>;
        <span class="hljs-built_in">add</span>(b, a);
    &#125;
    
    <span class="hljs-type">int</span> root = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">while</span> (has_fat[root]) root ++;
    
    <span class="hljs-built_in">dfs</span>(root);
    
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in">max</span>(f[root][<span class="hljs-number">1</span>], f[root][<span class="hljs-number">0</span>]));
&#125;</code></pre>



<h2 id="5-11-记忆搜索"><a href="#5-11-记忆搜索" class="headerlink" title="5.11 记忆搜索"></a>5.11 记忆搜索</h2><p>优势：代码简单</p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/903/">滑雪</a></p>
<pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">310</span>;
<span class="hljs-type">int</span> n, m;
<span class="hljs-type">int</span> h[N][N];
<span class="hljs-type">int</span> f[N][N];

<span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;, dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>&#125;;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span>  </span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-type">int</span> &amp;v = f[x][y];
    <span class="hljs-keyword">if</span> (v != <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> v;
    
    v = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i ++)
    &#123;
        <span class="hljs-type">int</span> a = x + dx[i], b = y + dy[i];
        <span class="hljs-keyword">if</span> (a &gt;= <span class="hljs-number">1</span> &amp;&amp; a &lt;= n &amp;&amp; b &gt;= <span class="hljs-number">1</span> &amp;&amp; b &lt;= m &amp;&amp; h[a][b] &lt; h[x][y])
            v = <span class="hljs-built_in">max</span>(v, <span class="hljs-built_in">dp</span>(a, b) + <span class="hljs-number">1</span>);
    &#125;
    
    <span class="hljs-keyword">return</span> v;
&#125;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);
    
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++)
            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;h[i][j]);
    
    <span class="hljs-built_in">memset</span>(f, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> f);
    
    <span class="hljs-type">int</span> res = <span class="hljs-number">-1</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++)
            res = <span class="hljs-built_in">max</span>(res, <span class="hljs-built_in">dp</span>(i, j));
            
    cout &lt;&lt; res &lt;&lt;endl;
    
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre>

<h2 id="5-12-数字三角形模型"><a href="#5-12-数字三角形模型" class="headerlink" title="5.12 数字三角形模型"></a>5.12 数字三角形模型</h2><h1 id="6-贪心"><a href="#6-贪心" class="headerlink" title="6. 贪心"></a>6. 贪心</h1><h2 id="6-1-区间问题"><a href="#6-1-区间问题" class="headerlink" title="6.1 区间问题"></a>6.1 区间问题</h2><p>区间问题的贪心，一般要以区间左端点或者区间右端点排序，再去尝试。</p>
</div></article><div class="copyright-wrapper"><p>原文作者:<a href="https://ainexur.github.io">ainexur</a></p><p>原文链接:<a href="https://ainexur.github.io/2021/09/25/acwing%E6%A8%A1%E6%9D%BF/">Acwing模板</a></p><p>发表日期: 2021-09-25 22:29:59</p><p>更新日期: 2023-04-02 23:52:57</p><p>版权声明: 本文采用<a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc/4.0/">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可</p></div><div class="post-pager"><div class="prev"><a href="/2021/09/28/AcWing%E7%AC%AC18%E5%9C%BA%E5%91%A8%E8%B5%9B/" title="AcWing第18场周赛">上一篇 AcWing第18场周赛</a></div><div class="next"> <a href="/2021/09/20/win7-USB%E7%BD%91%E5%8D%A1%E5%BC%80%E7%83%AD%E7%82%B9/" title="win7-USB网卡开热点">下一篇 win7-USB网卡开热点</a></div></div><link rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.css"/><script src="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.js"></script><div id="gitalk-container"></div><script>new Gitalk({
  clientID: '',
  clientSecret: '',
  repo: '',
  owner: '',
  admin: '',
  id: location.pathname.substr(0, 48),
  distractionFreeMode: true,
  labels: ['Gitalk'],
  title: 'Acwing模板',
}).render('gitalk-container');</script></section></section></main><footer class="footer-page"><div><span>Powered by</span><a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a><span>| Theme</span><a target="_blank" rel="noopener" href="https://github.com/techmovie/hexo-theme-instapaper">instapaper</a></div></footer><script src="/scripts/dark.js"></script><script src="/scripts/post.js"></script></body></html>