

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=dark>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/avatar.png">
  <link rel="icon" href="/img/avatar.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="ainexur">
  <meta name="keywords" content="博客">
  
    <meta name="description" content="0 语法与STL0.1 重定向输入输出12freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout);     0.2 程序运行时间12345double start,finish; &#x2F;* 开始时间,结束时间 *&#x2F; start&#x3D;(double)clock(">
<meta property="og:type" content="article">
<meta property="og:title" content="Acwing模板">
<meta property="og:url" content="https://ainexur.github.io/2021/09/25/acwing%E6%A8%A1%E6%9D%BF/index.html">
<meta property="og:site_name" content="寻人启事">
<meta property="og:description" content="0 语法与STL0.1 重定向输入输出12freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout);     0.2 程序运行时间12345double start,finish; &#x2F;* 开始时间,结束时间 *&#x2F; start&#x3D;(double)clock(">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://typoradrawingbed.oss-cn-guangzhou.aliyuncs.com/img/%E6%9C%80%E7%9F%AD%E8%B7%AF.png">
<meta property="article:published_time" content="2021-09-25T14:29:59.000Z">
<meta property="article:modified_time" content="2022-10-22T18:01:29.976Z">
<meta property="article:author" content="ainexur">
<meta property="article:tag" content="AcWing">
<meta property="article:tag" content="算法基础">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://typoradrawingbed.oss-cn-guangzhou.aliyuncs.com/img/%E6%9C%80%E7%9F%AD%E8%B7%AF.png">
  
  
  <title>Acwing模板 - 寻人启事</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/atom-one-dark.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"ainexur.github.io","root":"/","version":"1.8.14","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Nexur</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('https://typoradrawingbed.oss-cn-guangzhou.aliyuncs.com/background/2.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Acwing模板">
              
                Acwing模板
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-09-25 22:29" pubdate>
        2021年9月25日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      38k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      318 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Acwing模板</h1>
            
            <div class="markdown-body">
              <h1 id="0-语法与STL"><a href="#0-语法与STL" class="headerlink" title="0 语法与STL"></a>0 语法与STL</h1><h2 id="0-1-重定向输入输出"><a href="#0-1-重定向输入输出" class="headerlink" title="0.1 重定向输入输出"></a>0.1 重定向输入输出</h2><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;in.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin);<br><span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;out.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout); <br></code></pre></div></td></tr></table></figure>



<h2 id="0-2-程序运行时间"><a href="#0-2-程序运行时间" class="headerlink" title="0.2 程序运行时间"></a>0.2 程序运行时间</h2><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">double</span> start,finish; <span class="hljs-comment">/* 开始时间,结束时间 */</span> <br>start=(<span class="hljs-keyword">double</span>)<span class="hljs-built_in">clock</span>(); <span class="hljs-comment">/* 我的time.h内没有CLOCKS_PER_SEC */</span> <br><span class="hljs-comment">//中间放要测试的代码</span><br>finish=(<span class="hljs-keyword">double</span>)<span class="hljs-built_in">clock</span>(); <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.4fms&quot;</span>,(finish-start)); <br></code></pre></div></td></tr></table></figure>



<h2 id="0-3"><a href="#0-3" class="headerlink" title="0.3"></a>0.3</h2><p>c++常用函数</p>
<table>
<thead>
<tr>
<th>函数名</th>
<th>解释</th>
<th>返回值类型</th>
</tr>
</thead>
<tbody><tr>
<td><code>isalpha()</code></td>
<td>判断是否是字母</td>
<td>bool</td>
</tr>
<tr>
<td><code>tolower()</code></td>
<td>将字符转为小写</td>
<td>char</td>
</tr>
<tr>
<td><code>ceil()</code></td>
<td>向上取整</td>
<td></td>
</tr>
<tr>
<td><code>floor()</code></td>
<td>向下取整</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>函数名称    返回值【输入是字符char】<br>isalnum()    如果是字母或数字，返回true<br>isalpha()    如果是字母，返回true<br>isdigit()    如果是数字，返回true<br>islower()    如果是小写字母，返回true<br>ispunct()<br>如果是标点符号，返回true</p>
<p>isspace()    如果是空白字符，包括空格、进纸、换行符、回车、制表符等，返回true<br>isupper()    如果是大写字符，返回true<br>tolower()    如果是大写字符，返回其小写<br>toupper()    如果是小写字符，返回其大写<br>isxdigit()    如果是16进制数，返回true，如0-9、a-f、A-F<br>iscntrl()    如果是控制字符，返回true<br>isgraph()    如果是除空格以外的打印字符，返回true<br>isprint()    如果是打印字符，返回true</p>
<h3 id="0-1-1-结构体定义（带初始化）"><a href="#0-1-1-结构体定义（带初始化）" class="headerlink" title="0.1.1 结构体定义（带初始化）"></a>0.1.1 结构体定义（带初始化）</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span><br>    <span class="hljs-keyword">int</span> x, y;<br>    <span class="hljs-built_in">Node</span>(<span class="hljs-keyword">int</span> _x, <span class="hljs-keyword">int</span> _y) &#123;<br>        x = _x;<br>        y = _y;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>

<h2 id="0-4-对拍"><a href="#0-4-对拍" class="headerlink" title="0.4 对拍"></a>0.4 对拍</h2><h1 id="1-基础算法"><a href="#1-基础算法" class="headerlink" title="1 基础算法"></a>1 基础算法</h1><h2 id="1-1-排序"><a href="#1-1-排序" class="headerlink" title="1.1 排序"></a>1.1 排序</h2><h3 id="1-1-1-快速排序"><a href="#1-1-1-快速排序" class="headerlink" title="1.1.1 快速排序"></a>1.1.1 快速排序</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> q[], <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">int</span> x = q[(l + r) / <span class="hljs-number">2</span>], i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>        <span class="hljs-keyword">while</span> (q[++ i] &lt; x);<br>        <span class="hljs-keyword">while</span> (q[-- j] &gt; x);<br>        <span class="hljs-keyword">if</span> (i &lt; j) <span class="hljs-built_in">swap</span>(q[i], q[j]);<br>    &#125;<br>    <span class="hljs-built_in">quick_sort</span>(q, l, j);<br>    <span class="hljs-built_in">quick_sort</span>(q, j + <span class="hljs-number">1</span>, r);<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="1-1-2-快速选择"><a href="#1-1-2-快速选择" class="headerlink" title="1.1.2 快速选择"></a>1.1.2 快速选择</h3><p>选择数组里第k小数</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l == r) <span class="hljs-keyword">return</span> a[l];<br>    <span class="hljs-keyword">int</span> x = a[(l + r) &gt;&gt; <span class="hljs-number">1</span>], i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>        <span class="hljs-keyword">while</span> (a[ ++ i] &lt; x);<br>        <span class="hljs-keyword">while</span> (a[ -- j] &gt; x);<br>        <span class="hljs-keyword">if</span> (i &lt; j) <span class="hljs-built_in">swap</span>(a[i], a[j]);<br>    &#125; <br>    <span class="hljs-keyword">int</span> sl = j - l + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (sl &gt;= k) <span class="hljs-keyword">return</span> <span class="hljs-built_in">quick_sort</span>(l, j, k);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">quick_sort</span>(j + <span class="hljs-number">1</span>, r, k - sl);<br><br>&#125;<br></code></pre></div></td></tr></table></figure>



<h3 id="1-1-2-归并排序"><a href="#1-1-2-归并排序" class="headerlink" title="1.1.2 归并排序"></a>1.1.2 归并排序</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> q[], <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">merge_sort</span>(q, l, mid),<span class="hljs-built_in">merge_sort</span>(q, mid + <span class="hljs-number">1</span>, r);<br>    <br>    <span class="hljs-keyword">int</span> i = l, j = mid + <span class="hljs-number">1</span>, k = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)<br>        tmp[k ++] = q[i] &lt;= q[j] ? q[i ++] : q[j ++];<br>        <br>    <span class="hljs-keyword">while</span> (i &lt;= mid) tmp[k ++] = q[i ++];<br>    <span class="hljs-keyword">while</span> (j &lt;= r) tmp[k ++] = q[j ++];<br>    <br>    <span class="hljs-keyword">for</span> (i = l, j = <span class="hljs-number">0</span>; i &lt;= r; i ++, j ++) q[i] = tmp[j];<br>&#125;<br></code></pre></div></td></tr></table></figure>





<h2 id="1-2-查找"><a href="#1-2-查找" class="headerlink" title="1.2 查找"></a>1.2 查找</h2><h3 id="1-2-1-二分查找"><a href="#1-2-1-二分查找" class="headerlink" title="1.2.1 二分查找"></a>1.2.1 二分查找</h3><p>x的左边界</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>    <span class="hljs-keyword">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (q[mid] &gt;= x) r = mid;<br>    <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>x的右边界</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>    <span class="hljs-keyword">int</span> mid = l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (q[mid] &lt;= x) l = mid;<br>    <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>&#125;<br>cout &lt;&lt; l &lt;&lt; endl;<br></code></pre></div></td></tr></table></figure>

<h2 id="1-3-高精度"><a href="#1-3-高精度" class="headerlink" title="1.3 高精度"></a>1.3 高精度</h2><h3 id="1-3-1-高精度加法"><a href="#1-3-1-高精度加法" class="headerlink" title="1.3.1 高精度加法"></a>1.3.1 高精度加法</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">//C = A + B</span><br><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">add</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;A, vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;B)</span> </span>&#123;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; C;<br>    <span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>() || i &lt; B.<span class="hljs-built_in">size</span>(); i ++) &#123;<br>        <span class="hljs-keyword">if</span> (i &lt; A.<span class="hljs-built_in">size</span>()) t += A[i];<br>        <span class="hljs-keyword">if</span> (i &lt; B.<span class="hljs-built_in">size</span>()) t += B[i];<br>        C.<span class="hljs-built_in">push_back</span>(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (t) C.<span class="hljs-built_in">push_back</span>(t);<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="1-3-2-高精度减法"><a href="#1-3-2-高精度减法" class="headerlink" title="1.3.2 高精度减法"></a>1.3.2 高精度减法</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">//(bool) A &gt;= B</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;A, vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;B)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (A.<span class="hljs-built_in">size</span>() != B.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> A.<span class="hljs-built_in">size</span>() &gt; B.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = A.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i --) <br>        <span class="hljs-keyword">if</span> (A[i] != B[i])<br>            <span class="hljs-keyword">return</span> A[i] &gt; B[i];<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-comment">//C = A - B</span><br><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">sub</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;A, vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;B)</span> </span><br><span class="hljs-function">    <span class="hljs-title">if</span> <span class="hljs-params">(!cmp(A, B))</span> <span class="hljs-keyword">return</span> <span class="hljs-title">sub</span><span class="hljs-params">(B, A)</span></span>;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; C;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, t = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>(); i ++ ) &#123;<br>        t = A[i] - t;<br>        <span class="hljs-keyword">if</span> (i &lt; B.<span class="hljs-built_in">size</span>()) t -= B[i];<br>        C.<span class="hljs-built_in">push_back</span>((t + <span class="hljs-number">10</span>) % <span class="hljs-number">10</span>);<br>        <span class="hljs-keyword">if</span> (t &lt; <span class="hljs-number">0</span>) t = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> t = <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">while</span> (C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>(); 	<span class="hljs-comment">//去掉前导零</span><br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><br></code></pre></div></td></tr></table></figure>

<h3 id="1-3-3-高精度乘法（vector-int"><a href="#1-3-3-高精度乘法（vector-int" class="headerlink" title="1.3.3 高精度乘法（vector * int)"></a>1.3.3 高精度乘法（vector * int)</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">mul</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;A, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; C;<br>    <span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>() || t; i ++) &#123;<br>        <span class="hljs-keyword">if</span> (i &lt; A.<span class="hljs-built_in">size</span>()) t += A[i] * b;<br>        C.<span class="hljs-built_in">push_back</span>(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="1-3-4-高精度除法"><a href="#1-3-4-高精度除法" class="headerlink" title="1.3.4 高精度除法"></a>1.3.4 高精度除法</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">//C = 商， r = 余</span><br><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">div</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;A, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> &amp;r)</span> </span>&#123;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; C;<br>    r = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = A.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i --) &#123;<br>        r = r * <span class="hljs-number">10</span> + A[i];<br>        C.<span class="hljs-built_in">push_back</span>(r / b);<br>        r %= b;<br>    &#125;<br>    <span class="hljs-built_in">reverse</span>(C.<span class="hljs-built_in">begin</span>(), C.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">while</span> (C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="1-4-前缀和差分"><a href="#1-4-前缀和差分" class="headerlink" title="1.4 前缀和差分"></a>1.4 前缀和差分</h2><h3 id="1-4-1-一维前缀和"><a href="#1-4-1-一维前缀和" class="headerlink" title="1.4.1 一维前缀和"></a>1.4.1 一维前缀和</h3><blockquote>
<p>含义:    s[i] = a[1] + a[2] + … + a[i]</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) s[i] = s[i - <span class="hljs-number">1</span>] + a[i];<br></code></pre></div></td></tr></table></figure>

<h3 id="1-4-2-二维前缀和"><a href="#1-4-2-二维前缀和" class="headerlink" title="1.4.2 二维前缀和"></a>1.4.2 二维前缀和</h3><blockquote>
<p>含义: s[i][j] = a[0][0] 与a[i][j] 组成的矩阵的和</p>
<p>二维矩阵和： s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1]</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++)<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i][j]);<br>            <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++) <br>            s[i][j] = s[i - <span class="hljs-number">1</span>][j] + s[i][j - <span class="hljs-number">1</span>] - s[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + a[i][j];<br></code></pre></div></td></tr></table></figure>

<h3 id="1-4-3-一维差分"><a href="#1-4-3-一维差分" class="headerlink" title="1.4.3 一维差分"></a>1.4.3 一维差分</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> a[N], b[N];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    b[l] += x;<br>    b[r + <span class="hljs-number">1</span>] -= x;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="1-4-4-二维差分"><a href="#1-4-4-二维差分" class="headerlink" title="1.4.4 二维差分"></a>1.4.4 二维差分</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> a[N][N], b[N][N];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x1, <span class="hljs-keyword">int</span> y1, <span class="hljs-keyword">int</span> x2, <span class="hljs-keyword">int</span> y2, <span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    b[x1][y1] += x;<br>    b[x2 + <span class="hljs-number">1</span>][y1] -= x; <br>    b[x1][y2 + <span class="hljs-number">1</span>] -= x;<br>    b[x2 + <span class="hljs-number">1</span>][y2 + <span class="hljs-number">1</span>] += x;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="1-5-双指针算法"><a href="#1-5-双指针算法" class="headerlink" title="1.5 双指针算法"></a>1.5 双指针算法</h2><p><strong>核心：将<code>O(n^2)</code>的算法， 利用双指针能降为<code>O(n)</code></strong></p>
<p><strong>思路：先写一个暴力做法， 看一下i和j有没有单调规律</strong></p>
<h3 id="1-5-1-模板1"><a href="#1-5-1-模板1" class="headerlink" title="1.5.1 模板1"></a>1.5.1 模板1</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; n; i ++) &#123;<br>    <span class="hljs-comment">//加入i</span><br>    s[a[i]] ++;	<span class="hljs-comment">//s[]，计数器</span><br>    <span class="hljs-comment">//假如不满足， 右移j直到满足</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">check</span>()) j ++;<br>    <span class="hljs-comment">//记录答案</span><br>    ans = <span class="hljs-built_in">max</span>(ans, j - i + <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="1-6-位运算"><a href="#1-6-位运算" class="headerlink" title="1.6 位运算"></a>1.6 位运算</h2><h3 id="1-6-1-求n的二进制表示中第k位"><a href="#1-6-1-求n的二进制表示中第k位" class="headerlink" title="1.6.1 求n的二进制表示中第k位"></a>1.6.1 求<code>n</code>的二进制表示中第k位</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">(n &gt;&gt;) k &amp; <span class="hljs-number">1</span><br></code></pre></div></td></tr></table></figure>

<h3 id="1-6-2-x的最后一位1"><a href="#1-6-2-x的最后一位1" class="headerlink" title="1.6.2 x的最后一位1"></a>1.6.2 x的最后一位1</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> x &amp; -x; 	<span class="hljs-comment">// x &amp; (~x + 1) </span><br>&#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="1-7-离散化"><a href="#1-7-离散化" class="headerlink" title="1.7 离散化"></a>1.7 离散化</h2><p>大范围内少数量的数， 映射到从0开始的一段连续的值（下标）；</p>
<ol>
<li>可能存在重复元素 （去重）</li>
<li>如何算出x离散化后的值 （二分）</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; PII;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">300010</span>;<br><span class="hljs-keyword">int</span> n, m;<br><span class="hljs-keyword">int</span> a[N], s[N];<br>vector&lt;<span class="hljs-keyword">int</span>&gt; alls;<br>vector&lt;PII&gt; add, query;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = alls.<span class="hljs-built_in">size</span>() <span class="hljs-number">-1</span> ;<br>    <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>        <span class="hljs-keyword">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (alls[mid] &gt;= x) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> r + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>





<h2 id="1-8-区间合并"><a href="#1-8-区间合并" class="headerlink" title="1.8 区间合并"></a>1.8 区间合并</h2><p>将存在交集的区间合并为一个区间。</p>
<p>思路：</p>
<ol>
<li>按左边界为主序、右边界为次序排序</li>
<li>初始化一个初始区间（初始手里的区间）（起始边界都为负无穷）</li>
<li>从左往右遍历排序好的区间， 做如下合并操作：<ol>
<li>如果遍历到的区间左边界大于当前手里区间的右边界， 说明从该区间往后的区间都不可能与当前区间合并（即不重合、没有交集）（因为区间是排序好的），则手里区间是一个已合并后的确定区间，将该区间加入合并后的数组。手里区间替换为当前区间</li>
<li>如果遍历到的区间左边界小于当前手里区间的右边界， 说明两个区间存在交集、可以合并。则合并后的区间右边界为两者区间的最右边界，左边界不变（因为是按左边界排序，手里区间的左边界必&lt;=当前区间的左边界， 所以不用考虑左边界）</li>
</ol>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;PII&gt; &amp;segs)</span> </span>&#123;<br>    vector&lt;PII&gt; res;<br>    <span class="hljs-built_in">sort</span>(segs.<span class="hljs-built_in">begin</span>(), segs.<span class="hljs-built_in">end</span>());<br>    <br>    <span class="hljs-keyword">int</span> st = <span class="hljs-number">-2e9</span>, ed = <span class="hljs-number">-2e9</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> seg : segs) <br>        <span class="hljs-keyword">if</span> (ed &lt; seg.first) &#123;<br>            <span class="hljs-keyword">if</span> (st != <span class="hljs-number">-2e9</span>) res.<span class="hljs-built_in">push_back</span>(&#123;st, ed&#125;);<br>            st = seg.first, ed = seg.second;<br>        &#125; <span class="hljs-keyword">else</span> <br>            ed = <span class="hljs-built_in">max</span>(ed, seg.second);<br>            <br>    <span class="hljs-keyword">if</span> (st != <span class="hljs-number">-2e9</span>) res.<span class="hljs-built_in">push_back</span>(&#123;st, ed&#125;);<br>    <br>    segs = res;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h1 id="2-数据结构"><a href="#2-数据结构" class="headerlink" title="2 数据结构"></a>2 数据结构</h1><h2 id="2-1-单链表"><a href="#2-1-单链表" class="headerlink" title="2.1 单链表"></a>2.1 单链表</h2><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">int</span> head, e[N], ne[N], idx;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>    head = <span class="hljs-number">-1</span>, idx = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//头插</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add_to_head</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    e[idx] = x, ne[idx] = head, head = idx ++;<br>&#125;<br><br><span class="hljs-comment">//k后插x</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    e[idx] = x, ne[idx] = ne[k], ne[k] = idx ++;<br>&#125;<br><br><span class="hljs-comment">//移除k后一个</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    ne[k] = ne[ne[k]];<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="2-2-双链表"><a href="#2-2-双链表" class="headerlink" title="2.2 双链表"></a>2.2 双链表</h2><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">int</span> l[N], r[N], e[N], idx;<br><br><span class="hljs-comment">//初始化</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>    r[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>, l[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>, idx = <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-comment">//在k的右边插入x</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    e[idx] = x;<br>    l[idx] = k;<br>    r[idx] = r[k];<br>    l[r[k]] = idx;<br>    r[k] = idx ++;<br>&#125;<br><br><span class="hljs-comment">//删除第k点</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    r[l[k]] = r[k];<br>    l[r[k]] = l[k];<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="2-3-栈"><a href="#2-3-栈" class="headerlink" title="2.3 栈"></a>2.3 栈</h2><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-keyword">int</span> q[N], tt = <span class="hljs-number">0</span>;<br><span class="hljs-comment">//push</span><br>q[tt ++] = x;<br><br><span class="hljs-comment">//pop</span><br>tt --;<br><br><span class="hljs-comment">//empty?</span><br>tt &gt;= <span class="hljs-number">0</span>?<br><br></code></pre></div></td></tr></table></figure>



<h2 id="2-4-队列"><a href="#2-4-队列" class="headerlink" title="2.4 队列"></a>2.4 队列</h2><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-keyword">int</span> q[N], hh, tt;<br> <span class="hljs-comment">//push x – 向队尾插入一个数 x；</span><br>q[++ tt] = x;<br><span class="hljs-comment">// pop – 从队头弹出一个数；</span><br>++ hh;<br><span class="hljs-comment">// empty – 判断队列是否为空；</span><br>cout &lt;&lt; (hh &lt;= tt ? <span class="hljs-string">&quot;NO&quot;</span> : <span class="hljs-string">&quot;YES&quot;</span>) &lt;&lt; endl;<br><span class="hljs-comment">// query – 查询队头元素。</span><br>cout &lt;&lt; q[hh] &lt;&lt; endl;<br></code></pre></div></td></tr></table></figure>



<h2 id="2-4-单调栈"><a href="#2-4-单调栈" class="headerlink" title="2.4 单调栈"></a>2.4 单调栈</h2><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-keyword">int</span> stk[N], a[N], tt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>    tt = <span class="hljs-number">-1</span>;<br>    stk[ ++ tt] = <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-comment">//单调递增</span><br><span class="hljs-keyword">while</span> (tt &amp;&amp; stk[tt] &gt;= a[i]) tt --;<br>stk[++ tt] = x;<br></code></pre></div></td></tr></table></figure>

<h2 id="2-5-滑动窗口-（单调队列）"><a href="#2-5-滑动窗口-（单调队列）" class="headerlink" title="2.5 滑动窗口 （单调队列）"></a>2.5 滑动窗口 （单调队列）</h2><ol>
<li>先考虑暴力解法</li>
<li>考虑能不能去掉其中一些元素</li>
<li>考虑去掉元素后是否构成单调队列</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1000010</span>;<br><span class="hljs-keyword">int</span> n, k;<br><span class="hljs-keyword">int</span> a[N], q[N];<br><br><span class="hljs-keyword">int</span> hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) &#123;<br>    <span class="hljs-keyword">if</span> (hh &lt;= tt &amp;&amp; q[hh] &lt; i - k + <span class="hljs-number">1</span>) hh ++;<br>    <span class="hljs-comment">//单调递增</span><br>    <span class="hljs-keyword">while</span> (hh &lt;= tt &amp;&amp; a[q[tt]] &gt;= a[i]) tt--;<br>    q[++ tt] = i;<br>    <span class="hljs-keyword">if</span> (i &gt;= k - <span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, a[q[hh]]);<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="2-6-KMP"><a href="#2-6-KMP" class="headerlink" title="2.6 KMP"></a>2.6 KMP</h2><p>利用要匹配的字符串p的前字串的最大前后缀匹配长度，来对当前s[i] != p[j]时的，利用next[j + 1]的最大匹配度，直接跳转到s[i]匹配p[j]的阶段，从而减少重复计算，优化时间复杂度的算法。</p>
<p>重点：</p>
<ul>
<li>理解前后缀</li>
<li>理解为什么当前不匹配时可以跳到上一个最大匹配下标</li>
<li>理解next数组</li>
<li>理解next数组生成。</li>
</ul>
<h3 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100010</span>, M = <span class="hljs-number">1000010</span>;	<span class="hljs-comment">//字符数组的最大长度</span><br><span class="hljs-keyword">char</span> p[N], s[M];	<span class="hljs-comment">//s中匹配字符串p，从下标1开始</span><br><span class="hljs-keyword">int</span> ne[N];	<span class="hljs-comment">//p的next数组，从下标1开始</span><br></code></pre></div></td></tr></table></figure>
<h3 id="读入字符串"><a href="#读入字符串" class="headerlink" title="读入字符串"></a>读入字符串</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">cin &gt;&gt; n &gt;&gt; p + <span class="hljs-number">1</span> &gt;&gt; m &gt;&gt; s + <span class="hljs-number">1</span>;	<span class="hljs-comment">//n为字符串p的长度，m为字符串s的长度。两个字符数组都从1开始，方便代码</span><br></code></pre></div></td></tr></table></figure>

<h3 id="next数组"><a href="#next数组" class="headerlink" title="next数组"></a>next数组</h3><p>next[i] ：前i个字符形成的字符串的，前缀和后缀最大匹配</p>
<p>因为真前缀和真后缀不能取同样的起点和终点。同样的起点和终点不构成真前缀和真后缀。所以字符串长度最少为2，才有意义。</p>
<p>即长度小于2时，最大匹配为0。所以next[i]的i从2开始计算</p>
<ul>
<li><code>ne[i]</code>：前i个字符的前后缀最大匹配长度</li>
<li><code>j</code>：前i-1个字符的前后缀最大匹配长度</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>, j = <span class="hljs-number">0</span>; i &lt;= n; i ++) &#123;	<span class="hljs-comment">//i:前i个字符，j：前i-1个字符最大匹配长度</span><br>    <span class="hljs-keyword">while</span> (j &amp;&amp; p[i] != p[j + <span class="hljs-number">1</span>]) j = ne[j];	<span class="hljs-comment">//寻找最大匹配j，可能为0</span><br>    <span class="hljs-comment">//当j为0时说明前面的字串都没有任何匹配，就利用不到之前的匹配</span><br>    <span class="hljs-comment">//p[i]!=p[j + 1]，假如前一个字串的最大匹配长度是j，那么说明[1.j] 和[i-j,i-1]两个字串相同，那么就需要判断p[i]和p[j+1]</span><br>    <span class="hljs-comment">//1. p[i]==p[j+1]：即_abca时j=1, i=4;计算_abcab时，i=5, p[i]==p[j+1]，退出循环，即当前j对ne[i]是有效的</span><br>    <span class="hljs-comment">//2. p[i]!=p[j+1]: 即_abca时j=1, i=4;计算_abcaa时，i=5, p[i]!=p[j+1]意味着最大匹配不能以p[i-1]作为开始，要以多少作为开始，就从j=ne[j]开始（这里也利用到KMP思想），在这里j=ne[j]=ne[1]=0，这时j=0退出循环，即从头开始计算最大匹配</span><br>    <span class="hljs-keyword">if</span> (p[i] == p[j + <span class="hljs-number">1</span>]) j ++;	<span class="hljs-comment">//while循环处理好最大匹配</span><br>    <span class="hljs-comment">//可能为0，当为0时意味着从新匹配，就需要判断p[i]是否和p[j+1]（记住这里j+1即第一个字符，字符串数组从下标1开始），相等则匹配度为1；</span><br>    <span class="hljs-comment">//当j不为0即意味着不需要从头开始匹配，那么也意味着p[i]必定等于p[j+1]，这时候j++;</span><br>    ne[i] = j;	<span class="hljs-comment">//记录值</span><br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="KMP求S中的P的字符串匹配"><a href="#KMP求S中的P的字符串匹配" class="headerlink" title="KMP求S中的P的字符串匹配"></a>KMP求S中的P的字符串匹配</h3><p>利用next数组求字符串匹配（查找S中是否存在子串P）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; i &lt;= m; i ++) &#123;	<span class="hljs-comment">//i=1从头开始，一开始的最大匹配是j=0</span><br>    <span class="hljs-keyword">while</span> (j &amp;&amp; s[i] != p[j + <span class="hljs-number">1</span>]) j = ne[j];	<span class="hljs-comment">//对于当前s[i]，求可利用的j的最大值</span><br>    <span class="hljs-comment">//如果j为0，意味从头开始匹配，j没法再退</span><br>    <span class="hljs-comment">//否则s[i]!=p[j+1]时，j=ne[j]表示左移P串，即拿s[i]与p[ne[j]]比较</span><br>    <span class="hljs-keyword">if</span> (s[i] == p[j + <span class="hljs-number">1</span>]) j ++;	<span class="hljs-comment">//如果两个字符相等，匹配长度+1</span><br>    <span class="hljs-keyword">if</span> (j == n)  &#123;	 <span class="hljs-comment">//如果匹配长度=p的长度，则匹配成功</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, i - n);<br>        j = ne[j]; <span class="hljs-comment">//求下一个匹配时，需要将j回退，也就是考虑当前s[i]!=p[j],</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>



<h2 id="2-7-Trie树"><a href="#2-7-Trie树" class="headerlink" title="2.7 Trie树"></a>2.7 Trie树</h2><h4 id="2-7-1-字符串Trie"><a href="#2-7-1-字符串Trie" class="headerlink" title="2.7.1 字符串Trie"></a>2.7.1 字符串Trie</h4><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">20010</span>;<br><span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">int</span> s[N][<span class="hljs-number">26</span>], cnt[N], idx;<br><br><span class="hljs-comment">//插入</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(string str)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; str[i]; i++) &#123;<br>        <span class="hljs-keyword">int</span> u = str[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>        <span class="hljs-keyword">if</span> (!s[p][u]) s[p][u] = ++idx;<br>        p = s[p][u];<br>    &#125;<br>    cnt[p] ++;<br>&#125;<br><br><span class="hljs-comment">//查询</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(string str)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; str[i]; i ++) &#123;<br>        <span class="hljs-keyword">int</span> u = str[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>        <span class="hljs-keyword">if</span> (!s[p][u]) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        p = s[p][u];<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt[p];<br>&#125;<br></code></pre></div></td></tr></table></figure>



<h4 id="2-7-2-数字Trie"><a href="#2-7-2-数字Trie" class="headerlink" title="2.7.2 数字Trie"></a>2.7.2 数字Trie</h4><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">3100010</span>;<br><span class="hljs-keyword">int</span> son[N][<span class="hljs-number">2</span>], idx;<br><br><span class="hljs-comment">//0-1 Trie 插入x</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">31</span>; i &gt;= <span class="hljs-number">0</span>; i --) &#123;<br>        <span class="hljs-keyword">int</span> u = (x &gt;&gt; i) &amp; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (!son[p][u]) son[p][u] = ++ idx;<br>        p = son[p][u];<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//查询最大异或值</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>, ret = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">31</span>; i &gt;= <span class="hljs-number">0</span>; i --) &#123;<br>        <span class="hljs-keyword">int</span> u = (x &gt;&gt; i) &amp; <span class="hljs-number">1</span>;<br>        ret &lt;&lt;= <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (son[p][!u]) ret += <span class="hljs-number">1</span>, p = son[p][!u];<br>        <span class="hljs-keyword">else</span> p = son[p][u];<br>    &#125;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></div></td></tr></table></figure>



<h2 id="2-8-并查集"><a href="#2-8-并查集" class="headerlink" title="2.8 并查集"></a>2.8 并查集</h2><blockquote>
<p>1.合并两个集合</p>
<p>2.查询两个元素是否在同一个集合</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100010</span>;<br><br><span class="hljs-keyword">int</span> n, m;<br><span class="hljs-keyword">int</span> p[N], len[N];<br><br><span class="hljs-comment">//初始化</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i ++) p[i] = i, len[i] = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">//查</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> p[x] == x? x : p[x] = <span class="hljs-built_in">find</span>(p[x]);<br>&#125;<br><br><span class="hljs-comment">//并</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> fx = <span class="hljs-built_in">find</span>(x);<br>    <span class="hljs-keyword">int</span> fy = <span class="hljs-built_in">find</span>(y);<br>    <span class="hljs-keyword">if</span> (fx == fy) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span> (len[fx] &lt; len[fy]) <span class="hljs-built_in">swap</span>(fx, fy);<br>    len[fx] += len[fy];<br>    p[fy] = fx;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="2-9-堆"><a href="#2-9-堆" class="headerlink" title="2.9 堆"></a>2.9 堆</h2><ol>
<li>插入x</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-keyword">int</span> n, m;<br><span class="hljs-keyword">int</span> h[N], len;<br><br><span class="hljs-comment">//down</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">down</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> t = u;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">2</span> * u &lt;= len &amp;&amp; h[<span class="hljs-number">2</span> * u] &lt; h[t]) t = <span class="hljs-number">2</span> * u;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">2</span> * u + <span class="hljs-number">1</span> &lt;= len &amp;&amp; h[<span class="hljs-number">2</span> * u + <span class="hljs-number">1</span>] &lt; h[t]) t = <span class="hljs-number">2</span> * u + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (u != t)  &#123;<br>        <span class="hljs-built_in">swap</span>(h[u], h[t]);<br>        <span class="hljs-built_in">down</span>(t);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//up</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">up</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> t = u;<br>    <span class="hljs-keyword">while</span> (u / <span class="hljs-number">2</span> &amp;&amp; h[u / <span class="hljs-number">2</span>] &gt; h[u]) &#123;<br>        <span class="hljs-built_in">swap</span>(h[u / <span class="hljs-number">2</span>], h[u]);<br>        u /= <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>





<h3 id="2-9-2-堆（双指向版"><a href="#2-9-2-堆（双指向版" class="headerlink" title="2.9.2 堆（双指向版)"></a>2.9.2 堆（双指向版)</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">int</span> h[N], hp[N], ph[N], len;	<span class="hljs-comment">//ph：第i个插入的数在堆的哪个位置</span><br>							<span class="hljs-comment">//hp: 堆的第i个位置是第几个插入的数</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">heap_swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>    <span class="hljs-built_in">swap</span>(ph[hp[a]], ph[hp[b]]);<br>    <span class="hljs-built_in">swap</span>(hp[a], hp[b]);<br>    <span class="hljs-built_in">swap</span>(h[a], h[b]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">down</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> t = u;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">2</span> * u &lt;= len &amp;&amp; h[<span class="hljs-number">2</span> * u] &lt; h[t]) t = <span class="hljs-number">2</span> * u;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">2</span> * u + <span class="hljs-number">1</span> &lt;= len &amp;&amp; h[<span class="hljs-number">2</span> * u + <span class="hljs-number">1</span>] &lt; h[t]) t = <span class="hljs-number">2</span> * u + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (u != t) &#123;<br>        <span class="hljs-built_in">heap_swap</span>(u, t);<br>        <span class="hljs-built_in">down</span>(t);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">up</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (u &gt; <span class="hljs-number">1</span> &amp;&amp; h[u / <span class="hljs-number">2</span>] &gt; h[u]) &#123;<br>        <span class="hljs-built_in">heap_swap</span>(u / <span class="hljs-number">2</span>, u);<br>        u /= <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="3-哈希表"><a href="#3-哈希表" class="headerlink" title="3 哈希表"></a>3 哈希表</h2><h3 id="3-1-模拟散列表"><a href="#3-1-模拟散列表" class="headerlink" title="3.1 模拟散列表"></a>3.1 模拟散列表</h3><h4 id="3-1-1-拉链法"><a href="#3-1-1-拉链法" class="headerlink" title="3.1.1 拉链法"></a>3.1.1 拉链法</h4><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100003</span>;<br><span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">int</span> h[N], e[N], ne[N], idx;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> k = (x % N + N) % N;<br>    e[idx] = x;<br>    ne[idx] = h[k];<br>    h[k] = idx ++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> k = (x % N + N) % N;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = h[k]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>        <span class="hljs-keyword">if</span> (e[i] == x) <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>





<h4 id="3-1-2-开放式寻址法"><a href="#3-1-2-开放式寻址法" class="headerlink" title="3.1.2 开放式寻址法"></a>3.1.2 开放式寻址法</h4><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">200003</span>, null = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">int</span> h[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> k = (x % N + N) % N;<br>    <span class="hljs-keyword">while</span> (h[k] != null &amp;&amp; h[k] != x) &#123;<br>        k ++;<br>        <span class="hljs-keyword">if</span> (k == N) &#123;<br>            k = <span class="hljs-number">0</span>; <br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> k;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="3-2-字符串哈希-（字符串前缀哈希法）"><a href="#3-2-字符串哈希-（字符串前缀哈希法）" class="headerlink" title="3.2 字符串哈希 （字符串前缀哈希法）"></a>3.2 字符串哈希 （字符串前缀哈希法）</h3><p><strong>原理</strong>：将一个字符串看成一个P进制的数，将P进制数转换成十进制数，得到该字符串的哈希值。</p>
<p>例字：<code>ABCD</code>: A * P^3 + B * P^2 +  C * P^1 + D * P^0所得的十进制数就是该字符串的哈希值。</p>
<p>由于字符串可能很大，得到的数值会非常大，故对该数进行取模。由ULL溢出后自动取模做到这一步。取模后的数可能会由冲突，该算法的前提假设人品足够好，不考虑冲突的情况。</p>
<blockquote>
<ol>
<li><p>不能映射成0（如果<code>A</code>映射成0，那么<code>A</code>与<code>AA</code>、<code>AAA</code>将冲突</p>
</li>
<li><p>假设人品(Rp)足够好，假定不存在冲突</p>
</li>
</ol>
<p>经验值：p取131/13331， Q取2^64</p>
</blockquote>
<p><strong>好处</strong>：利用前缀哈希，计算出任何字串的哈希值。</p>
<blockquote>
<p>求区间[l,r]的字串的哈希值：<br>由于左边是高位，右边是低位，需要最低位对其。将h[l - 1]右移与h[r]右对齐（最低位）对齐后，相减的差即为该区间字串的哈希值。（右移r - l + 1位需要乘上P^(r - l + 1)）</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ULL;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100010</span>, P = <span class="hljs-number">131</span>;<br><br><span class="hljs-keyword">int</span> n, m;<br><span class="hljs-keyword">char</span> s[N]; <span class="hljs-comment">//字符串数组，下标从1开始，方便处理</span><br>ULL h[N], p[N];	<span class="hljs-comment">//h[N]字符串前缀哈希值，p[N] p的n次方数组（对ull取模后的值）</span><br><span class="hljs-comment">//求区间[l,r]的字串的哈希值：</span><br><span class="hljs-function">ULL <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> h[r] - h[l - <span class="hljs-number">1</span>] * p[r - l + <span class="hljs-number">1</span>];<br>&#125;<br><br>p[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-comment">//求取字符串前缀哈希值、P的次方值（p数组存）</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) &#123;<br>    p[i] = p[i - <span class="hljs-number">1</span>] * P;<br>    h[i] = h[i - <span class="hljs-number">1</span>] * P + s[i];<br>&#125;<br></code></pre></div></td></tr></table></figure>





<h1 id="3-搜索与图论"><a href="#3-搜索与图论" class="headerlink" title="3. 搜索与图论"></a>3. 搜索与图论</h1><h2 id="3-1-DFS"><a href="#3-1-DFS" class="headerlink" title="3.1 DFS"></a>3.1 DFS</h2><h3 id="3-1-1-交换法"><a href="#3-1-1-交换法" class="headerlink" title="3.1.1 交换法"></a>3.1.1 交换法</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">int</span> a[N];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (u == n) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, a[i]);<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = u; i &lt; n; i ++) &#123;<br>        <span class="hljs-built_in">swap</span>(a[i], a[u]);<br>        <span class="hljs-built_in">dfs</span>(u + <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">swap</span>(a[i], a[u]);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="3-1-2-回溯法"><a href="#3-1-2-回溯法" class="headerlink" title="3.1.2 回溯法"></a>3.1.2 回溯法</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">int</span> a[N];<br><span class="hljs-keyword">bool</span> vis[N];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (u == n) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, a[i]);<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) &#123;<br>        <span class="hljs-keyword">if</span> (vis[i]) <span class="hljs-keyword">continue</span>;<br>        vis[i] = <span class="hljs-literal">true</span>;<br>        a[u] = i + <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">dfs</span>(u + <span class="hljs-number">1</span>);<br>        vis[i] = <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="3-1-3-n皇后问题-朴素解法"><a href="#3-1-3-n皇后问题-朴素解法" class="headerlink" title="3.1.3 n皇后问题 (朴素解法)"></a>3.1.3 n皇后问题 (朴素解法)</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">20</span>;<br><span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">char</span> g[N][N];<br><span class="hljs-keyword">int</span> col[N], dg[N], udg[N];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (u == n) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) <span class="hljs-built_in">puts</span>(g[i]);<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>        <span class="hljs-keyword">if</span> (!col[i] &amp;&amp; !dg[u + i] &amp;&amp; !udg[n - u + i]) &#123;<br>            g[u][i] = <span class="hljs-string">&#x27;Q&#x27;</span>;<br>            col[i] = dg[u + i] = udg[n - u + i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-built_in">dfs</span>(u + <span class="hljs-number">1</span>);<br>            col[i] = dg[u + i] = udg[n - u + i] = <span class="hljs-literal">false</span>;<br>            g[u][i] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>        &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j ++)<br>            g[i][j] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>            <br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></div></td></tr></table></figure>

<h3 id="3-1-4-n皇后问题-位运算解法"><a href="#3-1-4-n皇后问题-位运算解法" class="headerlink" title="3.1.4 n皇后问题 (位运算解法)"></a>3.1.4 n皇后问题 (位运算解法)</h3><h2 id="3-2-BFS"><a href="#3-2-BFS" class="headerlink" title="3.2 BFS"></a>3.2 BFS</h2><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">110</span>;<br><span class="hljs-keyword">int</span> q[N];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> hh =<span class="hljs-number">0</span>,  tt = <span class="hljs-number">0</span>;<br>    q[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">while</span> (hh &lt;= tt) &#123;<br>        <span class="hljs-keyword">auto</span> t = q[hh ++];<br>        <span class="hljs-comment">//将t的周围加入队列q</span><br>        <span class="hljs-comment">//...</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>



<h2 id="3-3-树与图的DFS"><a href="#3-3-树与图的DFS" class="headerlink" title="3.3 树与图的DFS"></a>3.3 树与图的DFS</h2><h3 id="3-3-1-领接表"><a href="#3-3-1-领接表" class="headerlink" title="3.3.1 领接表"></a>3.3.1 领接表</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100010</span>, M = N * <span class="hljs-number">2</span>;<br><br><span class="hljs-keyword">int</span> h[N], e[M], ne[M], idx;<br><br><span class="hljs-comment">//领接表加边a-&gt;b</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;<br>&#125;<br><br></code></pre></div></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> h[N], w[N], e[N], ne[N], idx;<br><span class="hljs-comment">//add,a-&gt;b ，权重c</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> c)</span> </span>&#123;<br>    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;<br>&#125;<br></code></pre></div></td></tr></table></figure>





<h3 id="3-3-2-深度优先遍历"><a href="#3-3-2-深度优先遍历" class="headerlink" title="3.3.2 深度优先遍历"></a>3.3.2 深度优先遍历</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> h[N], e[M], ne[M], idx;<br><span class="hljs-keyword">int</span> vis[N];<br><br><span class="hljs-comment">//树的dfs</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span> </span><br><span class="hljs-function"></span>&#123;<br>    vis[u] = <span class="hljs-literal">true</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = h[u]; i != <span class="hljs-number">-1</span>; i = ne[i]) <br>    &#123;<br>        <span class="hljs-keyword">if</span> (!vis[e[i] ]) &#123;<br>            <span class="hljs-built_in">dfs</span>(e[i])<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="3-4-树与图的BFS"><a href="#3-4-树与图的BFS" class="headerlink" title="3.4 树与图的BFS"></a>3.4 树与图的BFS</h2><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100010</span>;<br><br><span class="hljs-keyword">int</span> n, m;<br><span class="hljs-keyword">int</span> h[N], e[N], ne[N], idx;<br><span class="hljs-keyword">int</span> d[N], q[N];<br><br><span class="hljs-comment">//add</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;<br>&#125;<br><br><span class="hljs-comment">//bfs</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span>  </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">0</span>;<br>    d[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    q[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">while</span> (hh &lt;= tt) <br>    &#123;<br>        <span class="hljs-keyword">int</span> t = q[hh ++];<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = h[t]; i != <span class="hljs-number">-1</span>; i = ne[i]) &#123;<br>            <span class="hljs-keyword">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (d[j] == <span class="hljs-number">-1</span>) &#123;<br>                d[j] = d[t] + <span class="hljs-number">1</span>;<br>                q[++ tt] = j;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> d[n];<br>&#125;<br></code></pre></div></td></tr></table></figure>





<h2 id="3-5-拓扑排序"><a href="#3-5-拓扑排序" class="headerlink" title="3.5 拓扑排序"></a>3.5 拓扑排序</h2><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100010</span>;<br><br><span class="hljs-keyword">int</span> h[N], e[N], ne[N], idx;<br><span class="hljs-keyword">int</span> d[N], q[N];<br><br><span class="hljs-keyword">int</span> n, m;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">topsort</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>        <span class="hljs-keyword">if</span> (!d[i])<br>            q[++ tt] = i;<br>            <br>    <span class="hljs-keyword">while</span> (hh &lt;= tt) &#123;<br>        <span class="hljs-keyword">int</span> t = q[hh ++];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = h[t]; i != <span class="hljs-number">-1</span>; i = ne[i]) &#123;<br>            <span class="hljs-keyword">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (-- d[j] == <span class="hljs-number">0</span>) <br>                q[++ tt] = j;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> tt == n - <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>



<h2 id="3-6-最短路"><a href="#3-6-最短路" class="headerlink" title="3.6 最短路"></a>3.6 最短路</h2><p><img src="https://typoradrawingbed.oss-cn-guangzhou.aliyuncs.com/img/%E6%9C%80%E7%9F%AD%E8%B7%AF.png" srcset="/img/loading.gif" lazyload></p>
<ol>
<li>单源最短路</li>
<li>多源汇最短路 ： 多个询问， 起点和终点的最短距离</li>
</ol>
<h3 id="3-6-1-Dijkstra（无负权边）"><a href="#3-6-1-Dijkstra（无负权边）" class="headerlink" title="3.6.1  Dijkstra（无负权边）"></a>3.6.1  Dijkstra（无负权边）</h3><p>n ：点数， m ： 边数</p>
<p>求两点之间的最短路，</p>
<blockquote>
<p><strong>前提条件</strong>：所有边都是正全权边（不存在负权边）</p>
</blockquote>
<h4 id="3-6-1-1-朴素Dijkstra"><a href="#3-6-1-1-朴素Dijkstra" class="headerlink" title="3.6.1.1 朴素Dijkstra"></a>3.6.1.1 朴素Dijkstra</h4><ol>
<li>初始化所有点的路径为无穷大，起点的路径修改为0</li>
<li>从未确定的点中，选取距离起点最近的点，将该点加入以确定的点的集合</li>
<li>用该点更新其他所有未确定的点距离</li>
<li>重复2-3，直到所有的点全部确定。</li>
</ol>
<blockquote>
<p>时间O(n ^ 2)， 适合稠密图</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">510</span>;<br><br><span class="hljs-keyword">int</span> n, m;<br><span class="hljs-keyword">int</span> g[N][N];	<span class="hljs-comment">//领接矩阵</span><br><span class="hljs-keyword">int</span> dist[N];	<span class="hljs-comment">//最短距离</span><br><span class="hljs-keyword">bool</span> st[N];		<span class="hljs-comment">//已确定的点集合</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//初始化</span><br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    <span class="hljs-built_in">memset</span>(st, <span class="hljs-literal">false</span>, <span class="hljs-keyword">sizeof</span> st);<br>    <br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-comment">//循环n次， 确定n个点的最短距离</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) <br>    &#123;<br>        <span class="hljs-keyword">int</span> t = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++)<br>            <span class="hljs-keyword">if</span> (!st[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || dist[t] &gt; dist[j]))<br>                t = j;<br>                <br>        st[t] = <span class="hljs-literal">true</span>; <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++)<br>            dist[j] = <span class="hljs-built_in">min</span>(dist[j], dist[t] + g[t][j]);<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (dist[n] == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h4 id="3-6-1-2-堆优化Dijkstra"><a href="#3-6-1-2-堆优化Dijkstra" class="headerlink" title="3.6.1.2 堆优化Dijkstra"></a>3.6.1.2 堆优化Dijkstra</h4><blockquote>
<p>时间O(m * lgn)， 适合稀疏图</p>
</blockquote>
<p>思路：利用优先队列， 将查找未确定的、距离最短的点这一步时间复杂度优化到logn</p>
<ol>
<li>初始点的距离为0， 加入优先队列</li>
<li>取出队列里头结点（该点的距离为未确定的点中的最短距离）</li>
<li>如果该点已经确定， 回到2</li>
<li>更新该点到邻点的距离（假如更新后的点距离更短），并将邻点的距离加入优先队列</li>
<li>重复2-4， 直至队列为空</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">150010</span>;<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; PII;<br><br><span class="hljs-keyword">int</span> n, m;<br><span class="hljs-keyword">int</span> h[N], e[N], w[N], ne[N], idx;<br><span class="hljs-keyword">int</span> dist[N];<br><span class="hljs-keyword">int</span> st[N];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> c)</span> </span>&#123;<br>    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    <span class="hljs-built_in">memset</span>(st, <span class="hljs-literal">false</span>, <span class="hljs-keyword">sizeof</span> st);<br>    <br>    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;<br>    <br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    heap.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;);<br>    <br>    <span class="hljs-keyword">while</span> (heap.<span class="hljs-built_in">size</span>() )<br>    &#123;<br>        <span class="hljs-keyword">auto</span> t = heap.<span class="hljs-built_in">top</span>(); heap.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">int</span> ver = t.second, distence = t.first;<br>        <span class="hljs-comment">//这个点已确定</span><br>        <span class="hljs-keyword">if</span> (st[ver]) <span class="hljs-keyword">continue</span>;<br>        st[ver] = <span class="hljs-literal">true</span>;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = h[ver]; i != <span class="hljs-number">-1</span>; i = ne[i]) &#123;<br>            <span class="hljs-keyword">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (dist[j] &gt; dist[ver] + w[i]) &#123;<br>                dist[j] = dist[ver] + w[i];<br>                heap.<span class="hljs-built_in">push</span>(&#123;dist[j], j&#125;);<br>                <span class="hljs-comment">// cout &lt;&lt; dist[j] &lt;&lt; &#x27; &#x27;;</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (dist[n] == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="3-6-2-带负权的最短路"><a href="#3-6-2-带负权的最短路" class="headerlink" title="3.6.2 带负权的最短路"></a>3.6.2 带负权的最短路</h3><h4 id="3-6-2-1-Bellman-Ford"><a href="#3-6-2-1-Bellman-Ford" class="headerlink" title="3.6.2.1 Bellman-Ford"></a>3.6.2.1 Bellman-Ford</h4><blockquote>
<p>O(n * m)</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">510</span>, M = <span class="hljs-number">10010</span>;<br><br><span class="hljs-keyword">int</span> n, m, k;<br><span class="hljs-keyword">int</span> dist[N], backup[N];<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span>&#123;</span><br>    <span class="hljs-keyword">int</span> a, b, c;<br>&#125;edges[M];<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bellman_ford</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    <br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i ++) <br>    &#123;<br>        <span class="hljs-built_in">memcpy</span>(backup, dist, <span class="hljs-keyword">sizeof</span> dist);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j ++) <br>        &#123;<br>            <span class="hljs-keyword">auto</span> [a, b, c] = edges[j];<br>            dist[b] = <span class="hljs-built_in">min</span>(dist[b], backup[a] + c);<br>        &#125;<br>    &#125;<br>        <br>    <span class="hljs-keyword">if</span> (dist[n] &gt; <span class="hljs-number">0x3f3f3f3f</span> / <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br></code></pre></div></td></tr></table></figure>



<h4 id="3-6-2-2-SPFA求最短路"><a href="#3-6-2-2-SPFA求最短路" class="headerlink" title="3.6.2.2 SPFA求最短路"></a>3.6.2.2 SPFA求最短路</h4><blockquote>
<p>O(m)， 最坏O(nm)</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100010</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><br><span class="hljs-keyword">int</span> n, m;<br><span class="hljs-keyword">int</span> h[N], e[N], w[N], ne[N], idx;<br><span class="hljs-keyword">int</span> dist[N];<br><span class="hljs-keyword">int</span> st[N];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> c)</span> </span>&#123;<br>    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    <br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <br>    queue&lt;<span class="hljs-keyword">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>    st[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br>    <br>    <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>() ) <br>    &#123;<br>        <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<br>        st[t] = <span class="hljs-literal">false</span>;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = h[t]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>        &#123;<br>            <span class="hljs-keyword">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (dist[j] &gt; dist[t] + w[i])<br>            &#123;<br>                dist[j] = dist[t] + w[i];<br>                <span class="hljs-keyword">if</span> (!st[j])<br>                &#123;<br>                    q.<span class="hljs-built_in">push</span>(j);<br>                    st[j] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h4 id="3-6-2-3-SPFA判负环"><a href="#3-6-2-3-SPFA判负环" class="headerlink" title="3.6.2.3 SPFA判负环"></a>3.6.2.3 SPFA判负环</h4><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">10010</span>;<br><br><span class="hljs-keyword">int</span> n, m;<br><span class="hljs-keyword">int</span> h[N], e[N], w[N], ne[N], idx;<br><span class="hljs-keyword">int</span> dist[N], cnt[N];<br><span class="hljs-keyword">int</span> st[N];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> c)</span> </span>&#123;<br>    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    queue&lt;<span class="hljs-keyword">int</span>&gt; q;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) &#123;<br>        q.<span class="hljs-built_in">push</span>(i);<br>        st[i] = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>() )<br>    &#123;<br>        <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<br>        st[t] = <span class="hljs-literal">false</span>;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = h[t]; i != <span class="hljs-number">-1</span>; i = ne[i]) <br>        &#123;<br>            <span class="hljs-keyword">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (dist[j] &gt; dist[t] + w[i]) <br>            &#123;<br>                dist[j] = dist[t] + w[i];<br>                cnt[j] = cnt[t] + <span class="hljs-number">1</span>;<br>                <br>                <span class="hljs-keyword">if</span> (cnt[j] &gt;= n) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                <br>                <span class="hljs-keyword">if</span> (!st[j]) &#123;<br>                    q.<span class="hljs-built_in">push</span>(j);<br>                    st[j] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br></code></pre></div></td></tr></table></figure>





<h2 id="3-7-多源汇最短路"><a href="#3-7-多源汇最短路" class="headerlink" title="3.7 多源汇最短路"></a>3.7 多源汇最短路</h2><h3 id="3-7-1-Floyd"><a href="#3-7-1-Floyd" class="headerlink" title="3.7.1 Floyd"></a>3.7.1 Floyd</h3><blockquote>
<p>O(n ^ 3)</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">210</span>, INF = <span class="hljs-number">1e9</span>;<br><span class="hljs-keyword">int</span> n, m, k;<br><span class="hljs-keyword">int</span> d[N][N];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">floyd</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt;= n; k ++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++)<br>                d[i][j] = <span class="hljs-built_in">min</span>(d[i][j], d[i][k] + d[k][j]);<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="3-8-最小生成树"><a href="#3-8-最小生成树" class="headerlink" title="3.8 最小生成树"></a>3.8 最小生成树</h2><h3 id="3-8-1-普利姆算法（Prim）"><a href="#3-8-1-普利姆算法（Prim）" class="headerlink" title="3.8.1 普利姆算法（Prim）"></a>3.8.1 普利姆算法（Prim）</h3><h4 id="3-8-1-1-稠密图（朴素版Prim）"><a href="#3-8-1-1-稠密图（朴素版Prim）" class="headerlink" title="3.8.1.1 稠密图（朴素版Prim）"></a>3.8.1.1 稠密图（朴素版Prim）</h4><blockquote>
<p>O(n^2)</p>
</blockquote>
<p>思路：</p>
<ol>
<li>初始化所有点的距离为正无穷</li>
<li>每次找到离集合最近的点， 用该点更新其余所有点到集合的距离</li>
<li>将该点加入集合</li>
<li>重复第2-3步n次</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">510</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><br><span class="hljs-keyword">int</span> n, m; <br><span class="hljs-keyword">int</span> g[N][N];<br><span class="hljs-keyword">int</span> dist[N];<br><span class="hljs-keyword">bool</span> st[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">prim</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    <br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>    &#123;<br>        <span class="hljs-keyword">int</span> t = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++)<br>            <span class="hljs-keyword">if</span> (!st[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || dist[t] &gt; dist[j]))<br>                t = j;<br>        <span class="hljs-comment">//不是第一个点且距离是正无穷， 说明与集合没有边相连        </span><br>        <span class="hljs-keyword">if</span> (i &amp;&amp; dist[t] == INF) <span class="hljs-keyword">return</span> INF;<br>        <span class="hljs-comment">// 第一个点时， 不用加权重</span><br>        <span class="hljs-keyword">if</span> (i) res += dist[t];<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++)<br>            <span class="hljs-keyword">if</span> (!st[j] &amp;&amp; dist[j] &gt; g[t][j])<br>                dist[j] = g[t][j];<br>        <br>        st[t] = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h4 id="3-8-1-2-稀疏图-（堆优化版Prim）"><a href="#3-8-1-2-稀疏图-（堆优化版Prim）" class="headerlink" title="3.8.1.2 稀疏图 （堆优化版Prim）"></a>3.8.1.2 稀疏图 （堆优化版Prim）</h4><blockquote>
<p>O(m logn)</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><br></code></pre></div></td></tr></table></figure>



<h3 id="3-8-2-克鲁斯卡尔算法（Kruskal）"><a href="#3-8-2-克鲁斯卡尔算法（Kruskal）" class="headerlink" title="3.8.2  克鲁斯卡尔算法（Kruskal）"></a>3.8.2  克鲁斯卡尔算法（Kruskal）</h3><blockquote>
<p>O(mlogm)</p>
</blockquote>
<ol>
<li>从小到大排序所有边    （O(mlogm)</li>
<li>枚举每条边， 假如a，b不连通， 将这条边加入集合里（选了这条边用以连通a,b)     (O(m))</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> tuple&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; TIII;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100010</span>,  M = <span class="hljs-number">200010</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><br><span class="hljs-keyword">int</span> n, m;<br>TIII g[M];<br><span class="hljs-keyword">int</span> p[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> p[x] == x ? x : p[x] = <span class="hljs-built_in">find</span>(p[x]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">kruskal</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">sort</span>(g, g + m);<br>    <span class="hljs-comment">//初始化并查集</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) p[i] = i;<br>    <br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-comment">//最小生成树</span><br>    <span class="hljs-keyword">int</span> num = n;    <span class="hljs-comment">//集合数量</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i ++)<br>    &#123;<br>        <span class="hljs-keyword">auto</span> [c, a, b] = g[i];<br>        a = <span class="hljs-built_in">find</span>(a), b = <span class="hljs-built_in">find</span>(b);<br>        <span class="hljs-comment">//如果a,b不连通， 连通a,b</span><br>        <span class="hljs-keyword">if</span> (a != b)<br>        &#123;<br>            p[a] = b;<br>            res += c;<br>            num --;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (num == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> res;<br>    <span class="hljs-keyword">return</span> INF;<br>&#125;<br></code></pre></div></td></tr></table></figure>



<h2 id="3-9-二分图"><a href="#3-9-二分图" class="headerlink" title="3.9 二分图"></a>3.9 二分图</h2><h3 id="3-9-1-判断二分图（染色法）"><a href="#3-9-1-判断二分图（染色法）" class="headerlink" title="3.9.1 判断二分图（染色法）"></a>3.9.1 判断二分图（染色法）</h3><ol>
<li>遍历所有点</li>
<li>如果该点未染色， dfs染色该点及后面的点</li>
<li>dfs过程中， 遇到未染色的点， dfs染色该点</li>
<li>dfs过程中， 遇到已染色的点。 该点的颜色和要染的颜色一样，不处理。 不一样则返回false，说明不是二分图</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100010</span>, M = <span class="hljs-number">200010</span>;<br><br><span class="hljs-keyword">int</span> n, m;<br><span class="hljs-keyword">int</span> h[N], e[M], ne[M], idx;<br><span class="hljs-keyword">int</span> color[N];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    color[u] = c;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = h[u]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>    &#123;<br>        <span class="hljs-keyword">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span> (!color[j])<br>        &#123;<br>            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">dfs</span>(j, <span class="hljs-number">3</span> - c)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (color[j] == c) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isb</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>    	<span class="hljs-keyword">if</span> (!color[i])<br>        	<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">dfs</span>(i, <span class="hljs-number">1</span>)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br></code></pre></div></td></tr></table></figure>



<h3 id="3-9-2-二分图最大匹配-（匈牙利算法）"><a href="#3-9-2-二分图最大匹配-（匈牙利算法）" class="headerlink" title="3.9.2 二分图最大匹配 （匈牙利算法）"></a>3.9.2 二分图最大匹配 （匈牙利算法）</h3><blockquote>
<p>O(n*m)</p>
</blockquote>
<p>思路：</p>
<ol>
<li>遍历所有点</li>
<li>find当前点的所有边，如果对点没有对象， 则找到一个匹配</li>
<li>如果有对象， 则find这个对象， 如果这个匹配的对象能找到另外的匹配。则当前点能与这个对点成匹配</li>
<li>两者都不符合， 则当前点无对象</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">510</span>, M = <span class="hljs-number">100010</span>;<br><span class="hljs-keyword">int</span> n1, n2, m;<br><span class="hljs-keyword">int</span> h[N], e[M], ne[M], idx;<br><span class="hljs-keyword">int</span> match[N];<br><span class="hljs-keyword">bool</span> st[N];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>&#123;<br>    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = h[x]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>    &#123;<br>        <span class="hljs-keyword">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span> (!st[j])<br>        &#123;<br>            st[j] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (match[j] == <span class="hljs-number">0</span> || <span class="hljs-built_in">find</span>(match[j]))<br>            &#123;<br>                match[j] = x;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">xyl</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n1; i ++)<br>    &#123;<br>        <span class="hljs-built_in">memset</span>(st, <span class="hljs-literal">false</span>, <span class="hljs-keyword">sizeof</span> st);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">find</span>(i)) res ++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h1 id="4-数学知识"><a href="#4-数学知识" class="headerlink" title="4. 数学知识"></a>4. 数学知识</h1><h2 id="4-1-质数"><a href="#4-1-质数" class="headerlink" title="4.1 质数"></a>4.1 质数</h2><h3 id="4-1-1-试除法-判定质数"><a href="#4-1-1-试除法-判定质数" class="headerlink" title="4.1.1 试除法-判定质数"></a>4.1.1 试除法-判定质数</h3><blockquote>
<p>O(sqrt(n))</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">is_prime</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= x / i; i ++)<br>        <span class="hljs-keyword">if</span> (x % i == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="4-1-2-试除法-分解质因数"><a href="#4-1-2-试除法-分解质因数" class="headerlink" title="4.1.2 试除法-分解质因数"></a>4.1.2 试除法-分解质因数</h3><blockquote>
<p>O(sqrt(n))</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">divised</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n / i; i ++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (n % i == <span class="hljs-number">0</span>)<br>        &#123;<br>           <br>            <span class="hljs-keyword">int</span> s = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (n % i == <span class="hljs-number">0</span>)<br>            &#123;<br>                n /= i;<br>                s ++;<br>            &#125;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>, i, s);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>, n, <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="4-1-3-质数筛"><a href="#4-1-3-质数筛" class="headerlink" title="4.1.3 质数筛"></a>4.1.3 质数筛</h3><blockquote>
<p>埃氏筛法 O(nloglogn)</p>
<p>欧拉筛 O(n)</p>
</blockquote>
<h4 id="埃氏筛法"><a href="#埃氏筛法" class="headerlink" title="埃氏筛法"></a>埃氏筛法</h4><blockquote>
<p>对于每个质数， 都把以它为质因子的数筛去</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1000010</span>;<br><span class="hljs-keyword">int</span> prime[N], cnt;<br><span class="hljs-keyword">bool</span> st[N];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">get_primes</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i ++)<br>        <span class="hljs-keyword">if</span> (!st[i])<br>        &#123;<br>            prime[cnt ++] = i;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + i; j &lt;= n; j += i)<br>                st[j] = <span class="hljs-literal">true</span>;<br>        &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h4 id="欧拉筛"><a href="#欧拉筛" class="headerlink" title="欧拉筛"></a>欧拉筛</h4><blockquote>
<p>ps : pj 是 i 的最小质因子时， pj 也是 pj * i 的最小质因子！</p>
<p>根据这个条件就能保证每个合数只被最小质因子筛一次</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1000010</span>;<br><span class="hljs-keyword">int</span> prime[N], cnt;<br><span class="hljs-keyword">bool</span> st[N];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">get_primes</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i ++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (!st[i]) prime[cnt ++] = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; prime[j] &lt;= n / i; j ++)<br>        &#123;<br>            st[prime[j] * i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (i % prime[j] == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;	<span class="hljs-comment">// 重</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="4-2-约数"><a href="#4-2-约数" class="headerlink" title="4.2 约数"></a>4.2 约数</h2><h3 id="4-2-1-试除法-求一个数的约数"><a href="#4-2-1-试除法-求一个数的约数" class="headerlink" title="4.2.1 试除法-求一个数的约数"></a>4.2.1 试除法-求一个数的约数</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">get_divisors</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n / i; i ++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (n % i == <span class="hljs-number">0</span>)<br>        &#123;<br>            res.<span class="hljs-built_in">push_back</span>(i);<br>            <span class="hljs-keyword">if</span> (i != n / i) res.<span class="hljs-built_in">push_back</span>(n / i);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-built_in">sort</span>(res.<span class="hljs-built_in">begin</span>(), res.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="4-2-2-约数个数"><a href="#4-2-2-约数个数" class="headerlink" title="4.2.2 约数个数"></a>4.2.2 约数个数</h3><blockquote>
<p>分解质因数后， 约数个数为所有质因数的指数+1的乘积</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> n;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br><br>unordered_map&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; mp;<br><span class="hljs-keyword">while</span> (n --)<br>&#123;<br>    <span class="hljs-keyword">int</span> x;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= x / i; i ++)<br>        <span class="hljs-keyword">while</span> (x % i == <span class="hljs-number">0</span>)<br>        &#123;<br>            x /= i;<br>            mp[i] ++;<br>        &#125;<br>    <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">1</span>) mp[x] ++;<br>&#125;<br><br>LL res = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [_x, v] : mp) res = res *(v + <span class="hljs-number">1</span>) % mod;<br></code></pre></div></td></tr></table></figure>



<h3 id="4-2-3-约数之和"><a href="#4-2-3-约数之和" class="headerlink" title="4.2.3 约数之和"></a>4.2.3 约数之和</h3><blockquote>
<p>所有约数可用质因数求出， 约数之和 = (p1^0 * p1^1*…*p1^a) * (p2^0*…*p2^a) * (px^0*…*px^a)</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">unordered_map&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; mp;<br>    <span class="hljs-keyword">while</span> (n --)<br>    &#123;<br>        <span class="hljs-keyword">int</span> x;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x);<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= x / i; i ++)<br>            <span class="hljs-keyword">while</span> (x % i == <span class="hljs-number">0</span>)<br>            &#123;<br>                x /= i;<br>                mp[i] ++;<br>            &#125;<br>            <br>        <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">1</span>) mp[x] ++;<br>    &#125;<br>    <br>    LL res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [p, a] : mp)<br>    &#123;<br>        LL t = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (a --) t = (t * p + <span class="hljs-number">1</span>) % mod;<br>        res = res * t % mod;<br>    &#125;<br></code></pre></div></td></tr></table></figure>



<h3 id="4-2-4-欧几里得算法"><a href="#4-2-4-欧几里得算法" class="headerlink" title="4.2.4 欧几里得算法"></a>4.2.4 欧几里得算法</h3><blockquote>
<p>gcd(a, b) = gcd(b, a % b)</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> b ? <span class="hljs-built_in">gcd</span>(b, a % b) : a;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="4-3-欧拉函数"><a href="#4-3-欧拉函数" class="headerlink" title="4.3 欧拉函数"></a>4.3 欧拉函数</h2><h3 id="4-3-1-欧拉函数"><a href="#4-3-1-欧拉函数" class="headerlink" title="4.3.1 欧拉函数"></a>4.3.1 欧拉函数</h3><blockquote>
<p>n的欧拉函数：1-n中与n互质的数的个数</p>
<p>= n (1 - 1 / p1) ( 1 - 1 / p2) (1 - 1 / p3)…(1 - 1 / pk)</p>
</blockquote>
<p>分解质因数， 假设质因数为p1 p2 p3 … pk:</p>
<ol>
<li>从1-n中去掉p1、p2、…pk的所有倍数</li>
<li>加上所有pi * pj 的倍数</li>
<li>减去所有pi * pj * pk的倍数</li>
<li>加上所有pi * pj * pk * pl的倍数</li>
<li>…</li>
<li>（根据容斥原理得到 = n (1 - 1 / p1) ( 1 - 1 / p2) (1 - 1 / p3)…(1 - 1 / pk) ）</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">euler_phi</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> res = n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n / i; i ++)<br>        <span class="hljs-keyword">if</span> (n % i == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">while</span> (n % i == <span class="hljs-number">0</span>) n /= i; <br>            res = res - (res / i);<br>        &#125;<br>    <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">1</span>) res = res - (res / n);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="4-3-2-筛法求欧拉函数"><a href="#4-3-2-筛法求欧拉函数" class="headerlink" title="4.3.2  筛法求欧拉函数"></a>4.3.2  筛法求欧拉函数</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">LL <span class="hljs-title">euler_shai</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    phi[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i ++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (!st[i])<br>        &#123;<br>            phi[i] = i - <span class="hljs-number">1</span>;<br>            primes[cnt ++] = i;<br>        &#125;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; primes[j] &lt;= n / i; j ++)<br>        &#123;<br>            <span class="hljs-keyword">auto</span> pj = primes[j];<br>            st[pj * i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (i % pj == <span class="hljs-number">0</span>) &#123;<br>                phi[i * pj] = (LL)phi[i] * pj;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            phi[i * pj] = (LL)phi[i] * phi[pj];<br>        &#125;<br>    &#125;<br>    <br>    LL res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) res += phi[i];<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></div></td></tr></table></figure>



<h2 id="4-4-快速幂"><a href="#4-4-快速幂" class="headerlink" title="4.4 快速幂"></a>4.4 快速幂</h2><h3 id="4-4-1-快速幂"><a href="#4-4-1-快速幂" class="headerlink" title="4.4.1 快速幂"></a>4.4.1 快速幂</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> LL;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">qmi</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> p)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (k) &#123;<br>        <span class="hljs-keyword">if</span> (k &amp; <span class="hljs-number">1</span>) res = (LL)res * a % p;<br>        k &gt;&gt;= <span class="hljs-number">1</span>;<br>        a = (LL)a * a % p;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></div></td></tr></table></figure>



<h3 id="4-4-2-快速幂求逆元"><a href="#4-4-2-快速幂求逆元" class="headerlink" title="4.4.2 快速幂求逆元"></a>4.4.2 快速幂求逆元</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> LL;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">qmi</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> p)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (k) &#123;<br>        <span class="hljs-keyword">if</span> (k &amp; <span class="hljs-number">1</span>) res = (LL) res * a % p;<br>        k &gt;&gt;= <span class="hljs-number">1</span>;<br>        a = (LL) a * a % p;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">niyuan</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (a % p) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in">qmi</span>(a, p - <span class="hljs-number">2</span>, p));<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;impossible&quot;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure>



<h2 id="4-5-扩展欧几里得算法"><a href="#4-5-扩展欧几里得算法" class="headerlink" title="4.5 扩展欧几里得算法"></a>4.5 扩展欧几里得算法</h2><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">exgcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> &amp;x, <span class="hljs-keyword">int</span> &amp;y)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>) &#123;<br>        x = <span class="hljs-number">1</span>, y = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>    <span class="hljs-keyword">int</span> d =  <span class="hljs-built_in">exgcd</span>(b, a % b, y, x);<br>    y -= a / b * x;<br>    <span class="hljs-keyword">return</span> d;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="4-5-2-线性同余方程"><a href="#4-5-2-线性同余方程" class="headerlink" title="4.5.2 线性同余方程"></a>4.5.2 线性同余方程</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> LL;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">exgcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> &amp;x, <span class="hljs-keyword">int</span> &amp;y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!b) &#123;<br>        x = <span class="hljs-number">1</span>, y = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>    <br>    <span class="hljs-keyword">int</span> d = <span class="hljs-built_in">exgcd</span>(b, a % b, y, x);<br>    y -= a / b * x;<br>    <span class="hljs-keyword">return</span> d;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <br>    <span class="hljs-keyword">while</span> (n --)<br>    &#123;<br>        <span class="hljs-keyword">int</span> a, b, m;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;m);<br>        <span class="hljs-keyword">int</span> x, y;<br>        <span class="hljs-keyword">int</span> d = <span class="hljs-built_in">exgcd</span>(a, m, x, y);<br>        <br>        <span class="hljs-keyword">if</span> (b % d) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;impossible&quot;</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, (LL)x * (b / d) % m);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h1 id="5-动态规划"><a href="#5-动态规划" class="headerlink" title="5.动态规划"></a>5.动态规划</h1><h2 id="5-1-01背包"><a href="#5-1-01背包" class="headerlink" title="5.1 01背包"></a>5.1 01背包</h2><p>题目：有n个体积和价值分别为vi和wi的物品，求体积不超过m的最大价值</p>
<h3 id="01背包-朴素解法"><a href="#01背包-朴素解法" class="headerlink" title="01背包-朴素解法"></a>01背包-朴素解法</h3><ul>
<li><p>集合表示</p>
<ul>
<li><code>f[i][j]</code>:从前<code>i</code>个物品中挑选（每个只能选一次），  总体积不超过<code>j</code>的最大价值的所有集合。</li>
<li>Max 所有集合中最大的价值</li>
</ul>
</li>
<li><p>状态转移：</p>
<ul>
<li>不选第i个物品：<code>f[i][j] = f[i - 1][j]</code></li>
<li>选第i个物品：<code>f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i])</code>    <code>j &gt;= v[i]</code></li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1010</span>;<br><span class="hljs-keyword">int</span> n, m;<br><span class="hljs-keyword">int</span> v[N], w[N], f[N][N];    <br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)   <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++) &#123;<br>        f[i][j] = f[i - <span class="hljs-number">1</span>][j];<br>        <span class="hljs-keyword">if</span> (j &gt;= v[i]) f[i][j] = <span class="hljs-built_in">max</span>(f[i][j], f[i - <span class="hljs-number">1</span>][j - v[i]] + w[i]);<br>    &#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="01背包-滚动数组"><a href="#01背包-滚动数组" class="headerlink" title="01背包-滚动数组"></a>01背包-滚动数组</h3><p>朴素解法中使用二维数组，仔细思考当前i的状态只由i-1转移得来，跟i-2、i-3等状态无关，即当前层只与上一层的状态有关，这种情况就可以用滚动数组来优化空间复杂度。滚动数组即开一个<code>f[2][m]</code>的数组，将一维重复利用，达到记录当前状态和上一状态目的。</p>
<p>使用滚动数组优化原数组，只需在滚动维度下边&amp;1即可。当i为奇数时，&amp;1=1；当i为偶数时，&amp;1=0，使用位运算可以方便编码。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1010</span>;<br><span class="hljs-keyword">int</span> n, m;<br><span class="hljs-keyword">int</span> f[<span class="hljs-number">2</span>][N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) &#123;<br>        <span class="hljs-keyword">int</span> v, w;<br>        cin &gt;&gt; v &gt;&gt; w;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++) &#123;<br>                f[i &amp; <span class="hljs-number">1</span>][j] = f[i - <span class="hljs-number">1</span> &amp; <span class="hljs-number">1</span>][j];<br>                <span class="hljs-keyword">if</span> (j &gt;= v)<br>                    f[i &amp; <span class="hljs-number">1</span>][j] = <span class="hljs-built_in">max</span>(f[i &amp; <span class="hljs-number">1</span>][j], f[i - <span class="hljs-number">1</span> &amp; <span class="hljs-number">1</span>][j - v] + w);<br>            &#125;<br>    &#125;<br>    cout &lt;&lt; f[n &amp; <span class="hljs-number">1</span>][m];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>



<h3 id="01背包-一维优化"><a href="#01背包-一维优化" class="headerlink" title="01背包-一维优化"></a>01背包-一维优化</h3><p>从朴素解法到滚动数组解法，优化了空间复杂度。思考二维的更新，当前v只会更新到v + j，即对数组前面的数值是没有影响的。若只使用一维记录时， 当j从大到小遍历，数组右边已遍历的视为当前i的记录，未遍历的视为i-1的记录（左边），即可无干扰的对数组进行更新。</p>
<p>注意一维优化的核心是，必须从大到小遍历容积j更新f[j]（若从小到大遍历j， 则可能当前物品被使用多次，即f[j]被更新多次）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1010</span>;<br><span class="hljs-keyword">int</span> n, m;<br><span class="hljs-keyword">int</span> f[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) &#123;<br>        <span class="hljs-keyword">int</span> v, w;  cin &gt;&gt; v &gt;&gt; w;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = m; j &gt;= v; j --)<br>            f[j] = <span class="hljs-built_in">max</span>(f[j], f[j - v] + w);<br>    &#125;<br>    cout &lt;&lt; f[m];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="5-2-完全背包"><a href="#5-2-完全背包" class="headerlink" title="5.2 完全背包"></a>5.2 完全背包</h2><p>有 N 种物品和一个容量是 V 的背包，每种物品都有无限件可用。求不超过背包体积的最大价值</p>
<h3 id="完全背包朴素解法"><a href="#完全背包朴素解法" class="headerlink" title="完全背包朴素解法"></a>完全背包朴素解法</h3><p>集合表示：</p>
<ul>
<li><code>f[i][j]</code>: 前<code>i</code>个物品（每个可以无限选），  总体积不超过<code>j</code>的最大价值。</li>
<li>max：<code>f[i][j]</code>的所有集合中的最大价值</li>
</ul>
<p>状态转移：</p>
<ul>
<li><p><code>f[i][j] = f[i - 1][j]</code>：不选当前物品i</p>
</li>
<li><p><code>f[i][j] = max(f[i][j], f[i - 1][j - v[i] * k] + w[i] * k)</code>    <code>j &gt;= v[i] * k</code>：选当前物品i，且总体积不超过j的的最大价值</p>
</li>
</ul>
<blockquote>
<p><code>n^3</code>，超时</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1010</span>;<br><span class="hljs-keyword">int</span> n, m;<br><span class="hljs-keyword">int</span> f[N][N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) &#123;<br>        <span class="hljs-keyword">int</span> v, w; cin &gt;&gt; v &gt;&gt; w;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++) &#123;<br>            f[i][j] = f[i - <span class="hljs-number">1</span>][j];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k * v &lt;= j; k ++)<br>            	f[i][j] = <span class="hljs-built_in">max</span>(f[i][j], f[i - <span class="hljs-number">1</span>][j - v * k] + w * k);<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; f[n][m];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="完全背包-时间优化（去重复计算"><a href="#完全背包-时间优化（去重复计算" class="headerlink" title="完全背包-时间优化（去重复计算"></a>完全背包-时间优化（去重复计算</h3><p>当某个物品体积小，可以选取多件时，更大的体积也支持选取多件，这两者中间就产生了重复的计算。计算大体积时，次大体积的为最优解，故不用比较此次大体积以下的计算。</p>
<p>当计算<code>f[i][j</code>]时，由 <code>f[i][j] = max(f[i][j], f[i - 1][j - v[i] * k] + w[i] * k)</code>展开，可得如下：</p>
<p><code>f[i][j] = max(f[i-1][j], f[i-1][j-v] + w, f[i-1][j-2v]+2w, f[i-1][j-3v]+3w, ……, f[i-1][j-kv]+kw)</code></p>
<p><code>f[i][j-v] = max(f[i-1][j-v], f[i-1][j-2v] + w, f[i-1][j-3v] + 2w, ……, f[i-1][j-kv] + (k-1)w)</code></p>
<blockquote>
<p>状态转移：</p>
<p><code>f[i][j] = max(f[i-1][j],f[i][j-v[i]]+w[i] </code></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1010</span>;<br><span class="hljs-keyword">int</span> n, m;<br><span class="hljs-keyword">int</span> f[N][N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) &#123;<br>        <span class="hljs-keyword">int</span> v, w;<br>        cin &gt;&gt; v &gt;&gt; w;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++) &#123;<br>            f[i][j] = f[i - <span class="hljs-number">1</span>][j];<br>            <span class="hljs-keyword">if</span> (j &gt;= v)<br>            f[i][j] = <span class="hljs-built_in">max</span>(f[i][j], f[i][j - v] + w);<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; f[n][m];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="完全背包-一维空间优化"><a href="#完全背包-一维空间优化" class="headerlink" title="完全背包-一维空间优化"></a>完全背包-一维空间优化</h3><p>当某些题目情况下内存限制，需要优化空间内存，完全背包可以使用一维数组来求解。</p>
<p><strong>理解思路1：</strong>完全背包的空间优化中，可以直接去掉一维的数组，来完成记录即可。</p>
<ul>
<li><code>f[i][j] = f[i - 1][j]</code>转换成<code>f[j]=f[j]</code>（省略不写）</li>
<li><code>f[i][j] = max(f[i][j], f[i][j - v] + w)</code>转换成<code>f[j]=f[j - v] + w</code>（省略不写）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1010</span>;<br><span class="hljs-keyword">int</span> n, m;<br><span class="hljs-keyword">int</span> f[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) &#123;<br>        <span class="hljs-keyword">int</span> v, w;<br>        cin &gt;&gt; v &gt;&gt; w;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++) &#123;<br>            <span class="hljs-keyword">if</span> (j &gt;= v)<br>            f[j] = <span class="hljs-built_in">max</span>(f[j], f[j - v] + w);<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; f[m];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>



<p><strong>理解思路2：</strong>01背包中的一维空间优化受限于每个物品只能选取一次，需要从大往小遍历体积，如若从小往大遍历，会造成物品重复选取。重复选取则正是完全背包符合的，重复的次数从0到无限次，符合完全背包的题目需求。所以只需要将01背包的思路反向遍历一次即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1010</span>;<br><span class="hljs-keyword">int</span> n, m;<br><span class="hljs-keyword">int</span> f[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) &#123;<br>        <span class="hljs-keyword">int</span> v, w;<br>        cin &gt;&gt; v &gt;&gt; w;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = v; j &lt;= m; j ++)<br>            f[j] = <span class="hljs-built_in">max</span>(f[j], f[j - v] + w);<br>    &#125; <br>    <br>    cout &lt;&lt; f[m];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="5-3-多重背包"><a href="#5-3-多重背包" class="headerlink" title="5.3 多重背包"></a>5.3 多重背包</h2><p>有 N种物品和一个容量是 V 的背包。第 i 种物品最多有 si 件，每件体积是 vi，价值是 wi。求使物品体积总和不超过背包容量的最大价值。</p>
<h3 id="01背包思路"><a href="#01背包思路" class="headerlink" title="01背包思路"></a>01背包思路</h3><p>第i种物品最多有si件，可以看成01背包中的si件相同的物品，这样即可套用01背包的思路和代码来解</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">110</span>;<br><span class="hljs-keyword">int</span> n, m;<br><span class="hljs-keyword">int</span> f[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">while</span> (n --) &#123;<br>        <span class="hljs-keyword">int</span> v, w, s;<br>        cin &gt;&gt; v &gt;&gt; w &gt;&gt; s;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= s; i ++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = m; j &gt;= v; j --)<br>                f[j] = <span class="hljs-built_in">max</span>(f[j], f[j - v] + w);<br>    &#125;<br>    <br>    cout &lt;&lt; f[m];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>



<h3 id="完全背包思路"><a href="#完全背包思路" class="headerlink" title="完全背包思路"></a>完全背包思路</h3><p>可以将多重背包当成完全背包来推，只是每个i物品的数量k有限制。</p>
<p>集合表示：</p>
<ul>
<li><code>f[i][j]</code>: 前<code>i</code>个物品（每个可以无限选），  总体积不超过<code>j</code>的最大价值。</li>
<li>max：<code>f[i][j]</code>的所有集合中的最大价值</li>
</ul>
<p>状态转移：</p>
<ul>
<li><code>f[i][j] = f[i - 1][j]</code>：不选当前物品i</li>
<li><code>f[i][j] = max(f[i - 1][j], f[i - 1][j - v[i]*k] + w[i] * k)</code>    <code>j &gt;= v[i] * k &amp;&amp; k &lt;= s</code> ：选当前物品i，且总体积不超过j，数量不超过s的最大价值</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">110</span>;<br><span class="hljs-keyword">int</span> f[N][N];<br><span class="hljs-keyword">int</span> n, m;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) &#123;<br>        <span class="hljs-keyword">int</span> v, w, s;<br>        cin &gt;&gt; v &gt;&gt; w &gt;&gt; s;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k * v &lt;= j &amp;&amp; k &lt;= s; k ++) <br>                f[i][j] = <span class="hljs-built_in">max</span>(f[i][j], f[i - <span class="hljs-number">1</span>][j - v * k] + w * k);<br>        &#125;<br>    &#125;<br>    <br>    cout &lt;&lt; f[n][m];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="二进制优化"><a href="#二进制优化" class="headerlink" title="二进制优化"></a>二进制优化</h3><p>物品i有数量si个时，可选的数量区间为[0,s]，物品i对最优解的贡献数量一定位于该闭区间内。是否存在一种数学优化，使得枚举该区间的所有数量值的复杂度优于O(n)？答案是使用二进制枚举。</p>
<p>将s个物品拆分成1，2，4，8，2^k，·······，c个，且1+2+4+8+<code>2^k</code>的和为s，可证明[0,s]区间内的所有数都可由这些数相加组成，将原有的n个数转化为logn个数的，再运用01背包思路求解这些数，可求出所有体积下应选该物品的数量和最大价值，时间复杂度将每个物品的O(n)优化到O(logn)。运用该二进制优化到所有的物品中，即可将多重背包转化成优化的01背包问题。套用01背包求解，即可得出答案。</p>
<p>难点：理解二进制优化的思想，为什么可以使用二进制优化？</p>
<p>代码一：将每个物品分割都记录下来，和思路一样。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">15000</span>, M = <span class="hljs-number">2010</span>;<br><span class="hljs-keyword">int</span> n, m;<br><span class="hljs-keyword">int</span> v[N], w[N];<br><span class="hljs-keyword">int</span> f[M];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (n --) &#123;<br>        <span class="hljs-keyword">int</span> a, b, s;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; s;<br>        <span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (k &lt;= s) &#123;<br>            cnt ++;<br>            v[cnt] = a * k;<br>            w[cnt] = b * k;<br>            s -= k;<br>            k &lt;&lt;= <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (s &gt; <span class="hljs-number">0</span>) &#123;<br>            cnt ++;<br>            v[cnt] = a * s;<br>            w[cnt] = b * s;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= cnt; i ++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = m; j &gt;= v[i]; j --)<br>            f[j] = <span class="hljs-built_in">max</span>(f[j], f[j - v[i]] + w[i]);<br>    <br>    cout &lt;&lt; f[m];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>代码二：将物品的每个分割不做记录直接计算，省一点空间，但比较绕一丢丢，需要深刻理解01背包。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">2010</span>;<br><span class="hljs-keyword">int</span> n, m;<br><span class="hljs-keyword">int</span> f[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) &#123;<br>        <span class="hljs-keyword">int</span> v, w, s; cin &gt;&gt; v &gt;&gt; w &gt;&gt; s;<br>        <span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (k &lt;= s) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = m; j &gt;= v * k; j --)<br>                f[j] = <span class="hljs-built_in">max</span>(f[j], f[j - v * k] + w * k);<br>            s -= k;<br>            k &lt;&lt;= <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (s) <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = m;  j &gt;= v * s; j --)<br>                    f[j] = <span class="hljs-built_in">max</span>(f[j], f[j - v * s] + w * s);<br>    &#125;<br>    cout &lt;&lt; f[m];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="单调队列优化"><a href="#单调队列优化" class="headerlink" title="单调队列优化"></a>单调队列优化</h3><p>当计算<code>f[i][j</code>]时，由 <code>f[i][j] = max(f[i][j], f[i - 1][j - v * s] + w * s)</code>展开，可得如下：</p>
<p><code>f[i][j] = max(f[i-1][j], f[i-1][j-v] + w, f[i-1][j-2v]+2w, f[i-1][j-3v]+3w, ……, f[i-1][j-sv]+sw)</code></p>
<p><code>f[i][j-v] = max(f[i-1][j-v], f[i-1][j-2v] + w, f[i-1][j-3v] + 2w, ……, f[i-1][j-(s + 1)v] + sw)</code></p>
<p>再求取<code>f[i][j-v]</code>时，可以使用单调队列维护<code>f[i][j-v]</code>使得查找该过程的复杂度为O(1)，</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">20010</span>;<br><span class="hljs-keyword">int</span> n, m;<br><span class="hljs-keyword">int</span> f[N], g[N], q[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) &#123;<br>        <span class="hljs-keyword">int</span> v, w, s; cin &gt;&gt; v &gt;&gt; w &gt;&gt; s;<br>        <span class="hljs-built_in">memcpy</span>(g, f, <span class="hljs-keyword">sizeof</span> f);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; v; j ++) &#123;<br>            <span class="hljs-keyword">int</span> hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = j; k &lt;= m; k += v) &#123;<br>                <span class="hljs-keyword">while</span> (hh &lt;= tt &amp;&amp; q[hh] &lt; k - s * v) hh ++;<br>                <span class="hljs-keyword">if</span> (hh &lt;= tt) f[k] = <span class="hljs-built_in">max</span>(f[k], g[q[hh]] + (k - q[hh]) / v * w);<br>                <span class="hljs-keyword">while</span> (hh &lt;= tt &amp;&amp; g[q[tt]] - (q[tt] - j) / v * w &lt;= g[k] - (k - j) / v * w) tt --;<br>                q[++ tt] = k;<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; f[m] &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>



<h2 id="5-4-分组背包"><a href="#5-4-分组背包" class="headerlink" title="5.4 分组背包"></a>5.4 分组背包</h2><p>分组背包解决的是有n组，每组最多选一个物品，装进总容量为V的背包中，求最大价值。</p>
<p>状态表示：</p>
<ul>
<li>集合：<code>f[i][j]</code>：前i组背包中选，总体积不超过j的最大价值</li>
<li>属性：Max</li>
</ul>
<p>状态计算：</p>
<ul>
<li><code>f[i][j]</code> = <code>max(f[i][j], f[i - 1][j])</code>：当前i组不选</li>
<li><code>f[i][j]</code>= <code>max(f[i - 1][j], max(f[i - 1][j - vk] + wk))</code>：当前i组选第i个</li>
</ul>
<blockquote>
<p>注意分组背包的题目中，要把物品输入用数组记录下来，不能一边输入一边计算，因为容量的遍历要在分组背包前。否则就是01背包不是分组背包了</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">110</span>;<br><span class="hljs-keyword">int</span> n, m;<br><span class="hljs-keyword">int</span> v[N][N], w[N][N], s[N];<br><span class="hljs-keyword">int</span> f[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) &#123;<br>        cin &gt;&gt; s[i];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= s[i]; j ++) &#123;<br>            cin &gt;&gt; v[i][j] &gt;&gt; w[i][j];<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = m; j &gt;= <span class="hljs-number">0</span>; j --) <br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt;= s[i]; k ++)<br>                <span class="hljs-keyword">if</span> (j &gt;= v[i][k])<br>                    f[j] = <span class="hljs-built_in">max</span>(f[j], f[j - v[i][k]] + w[i][k]);<br>    <br>    cout &lt;&lt; f[m];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="5-5-最长上升子序列"><a href="#5-5-最长上升子序列" class="headerlink" title="5.5 最长上升子序列"></a>5.5 最长上升子序列</h2><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1010</span>;<br><span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">int</span> a[N], f[N];<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">f[i] = max(f[i], f[j] + 1) (a[i] &gt; a[j])</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>    &#123;<br>        f[i] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; i; j ++)<br>            <span class="hljs-keyword">if</span> (a[i] &gt; a[j])<br>                f[i] = <span class="hljs-built_in">max</span>(f[i], f[j] + <span class="hljs-number">1</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>        res = <span class="hljs-built_in">max</span>(res, f[i]);<br>        <br>    cout &lt;&lt; res;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>



<p><strong>n log n</strong>：</p>
<p>单调优化：即f[i]为0~i中最长上升子序列的最小增长序列</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-keyword">int</span> a[N];<br><span class="hljs-keyword">int</span> q[N];<br><span class="hljs-keyword">int</span> n;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]);<br>    <br>    <br>    q[<span class="hljs-number">0</span>] = <span class="hljs-number">-2e9</span>;<br>    <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>    &#123;<br>        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = len;<br>        <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>            <span class="hljs-keyword">int</span> mid = l + (r - l + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (q[mid] &lt; a[i]) l = mid;<br>            <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>        <br>        len = <span class="hljs-built_in">max</span>(len, r + <span class="hljs-number">1</span>);<br>        q[r + <span class="hljs-number">1</span>] = a[i];<br>    &#125;<br>    <br>    cout &lt;&lt; len &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>



<h2 id="5-6-最长公共子序列"><a href="#5-6-最长公共子序列" class="headerlink" title="5.6 最长公共子序列"></a>5.6 最长公共子序列</h2><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1010</span>;<br><span class="hljs-keyword">int</span> n, m;<br><span class="hljs-keyword">char</span> a[N], b[N];<br><span class="hljs-keyword">int</span> f[N][N];<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">f[i][j] = max(f[i - 1][j], f[i][j - 1], f[i - 1][j - 1] + 1)</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s%s&quot;</span>, a + <span class="hljs-number">1</span>, b + <span class="hljs-number">1</span>);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++) &#123;<br>            f[i][j] = <span class="hljs-built_in">max</span>(f[i - <span class="hljs-number">1</span>][j], f[i][j - <span class="hljs-number">1</span>]);<br>            <span class="hljs-keyword">if</span> (a[i] == b[j]) f[i][j] = <span class="hljs-built_in">max</span>(f[i][j], f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);<br>        &#125;<br>        <br>    cout &lt;&lt; f[n][m];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="5-7-区间DP-石子合并"><a href="#5-7-区间DP-石子合并" class="headerlink" title="5.7 区间DP-石子合并"></a>5.7 区间DP-石子合并</h2><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">310</span>;<br><span class="hljs-keyword">int</span> s[N];<br><span class="hljs-keyword">int</span> f[N][N];<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">f[i][j] = min(f[i][k] + f[k + 1][j] + s[j] - s[i - 1]);</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;s[i]);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) s[i] += s[i - <span class="hljs-number">1</span>];<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> len = <span class="hljs-number">2</span>; len &lt;= n; len ++) <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i + len - <span class="hljs-number">1</span> &lt;= n; i ++) &#123;<br>            <span class="hljs-keyword">int</span> l = i, r = i + len - <span class="hljs-number">1</span>;<br>            f[l][r] = <span class="hljs-number">1e9</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = l;  k &lt; r; k ++)<br>                f[l][r] = <span class="hljs-built_in">min</span>(f[l][r], f[l][k] + f[k + <span class="hljs-number">1</span>][r] + s[r] - s[l - <span class="hljs-number">1</span>]);<br>        &#125;<br>        <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, f[<span class="hljs-number">1</span>][n]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="5-8-计数DP"><a href="#5-8-计数DP" class="headerlink" title="5.8 计数DP"></a>5.8 计数DP</h2><p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/340/">计数问题</a></p>
<p>求某个区间内的所有数字上0-9出现的次数。</p>
<p>考虑 abcdefg 中第四位上1出现的次数</p>
<ol>
<li>如果前三位 = 0~abc-1, 那1的次数是： abc * 1000 （加入x = 0 时要从001开始，所以是 (abc -1) * 1000)</li>
<li>如果前三位 = abc：<ol>
<li>d &lt; 1, 那么无论后面efg取什么，都是不符合：0</li>
<li>d = 1, 后三位可取0~efg：efg+1</li>
<li>d &gt; 1, 后三位可取0~999：1000</li>
</ol>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;v, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = r; i &gt;= l; i --)<br>        res = res * <span class="hljs-number">10</span> + v[i];<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">power10</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i --) res *= <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">count</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!n) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <br>    vector&lt;<span class="hljs-keyword">int</span>&gt; v;<br>    <span class="hljs-keyword">for</span> (; n; n /= <span class="hljs-number">10</span>)<br>        v.<span class="hljs-built_in">push_back</span>(n % <span class="hljs-number">10</span>);<br>    <br>    n = v.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span> - !x; i &gt;= <span class="hljs-number">0</span>; i --)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (i &lt; n - <span class="hljs-number">1</span>) &#123;<br>            res += <span class="hljs-built_in">get</span>(v, i + <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>) * <span class="hljs-built_in">power10</span>(i);<br>            <span class="hljs-keyword">if</span> (!x) res -= <span class="hljs-built_in">power10</span>(i);<br>        &#125;<br>        <span class="hljs-comment">// cout &lt;&lt;&quot;--&quot; &lt;&lt; res &lt;&lt; endl;</span><br>        <span class="hljs-keyword">if</span> (v[i] == x) res += <span class="hljs-built_in">get</span>(v, <span class="hljs-number">0</span>, i - <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (v[i] &gt; x) res += <span class="hljs-built_in">power10</span>(i);<br>        <span class="hljs-comment">// cout &lt;&lt; &quot;--&quot; &lt;&lt; res &lt;&lt; endl;</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> a, b;<br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; a &gt;&gt; b, a || b)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (a &gt; b) <span class="hljs-built_in">swap</span>(a, b);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i ++)<br>            cout &lt;&lt; <span class="hljs-built_in">count</span>(b, i) - <span class="hljs-built_in">count</span>(a - <span class="hljs-number">1</span>, i) &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>        cout &lt;&lt; endl;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></div></td></tr></table></figure>







<h2 id="5-9-状态压缩"><a href="#5-9-状态压缩" class="headerlink" title="5.9 状态压缩"></a>5.9 状态压缩</h2><p>状态压缩，将某一状态用二进制01表示，用十进制存储，从而可以快速利用与或非等位运算，优化时空复杂度。</p>
<p>状态压缩通常会在题目上给出范围，当数据范围小时，就可以考虑是否能运用状态压缩</p>
<p>例题：</p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/293/"><strong>蒙德里安的梦想</strong></a></p>
<p>核心：<strong>先放横着的，再放竖着的</strong>。总的方案数等于合法的放置横着的方案数。</p>
<p>怎么判断横着的方案是否合法？所有列的竖着的连续空格是偶数个，才是合法</p>
<p>可以预处理一些状态，优化时间复杂度</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">f[i][j]表示i-1列的横着放着的长方形伸到i列的状态为j的合法方案数</span><br><span class="hljs-comment">f[i][j] = sum(f[i-1][k]) (k &amp; j == 0 &amp;&amp; state[k|j])</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>  LL;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">12</span>, M = <span class="hljs-number">1</span> &lt;&lt; N;<br><span class="hljs-keyword">int</span> n, m;<br>LL f[N][M];<br>vector&lt;<span class="hljs-keyword">int</span>&gt; state[M];<br><span class="hljs-keyword">bool</span> st[M];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; n &gt;&gt; m, n || m) &#123;<br>        <span class="hljs-comment">//预处理st：能否合法放置的列</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1</span> &lt;&lt; n; i ++)<br>        &#123;<br>            <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>, is_vaild = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j ++)<br>            &#123;<br>                <span class="hljs-keyword">if</span> ((i &gt;&gt; j) &amp; <span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (cnt &amp; <span class="hljs-number">1</span>) &#123; is_vaild = <span class="hljs-literal">false</span>; <span class="hljs-keyword">break</span>; &#125;<br>                    cnt = <span class="hljs-number">0</span>;<br>                &#125; <span class="hljs-keyword">else</span> cnt ++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (cnt &amp; <span class="hljs-number">1</span>) is_vaild = <span class="hljs-literal">false</span>;<br>            st[i] = is_vaild;<br>            <span class="hljs-comment">// cout &lt;&lt; st[i] &lt;&lt; &quot; &quot;;</span><br>        &#125;<br>        <br>        <span class="hljs-comment">//预处理两列伸出不重叠冲突</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1</span> &lt;&lt; n; i ++)<br>        &#123;<br>            state[i].<span class="hljs-built_in">clear</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">1</span> &lt;&lt; n; j ++)<br>            &#123;<br>                <span class="hljs-keyword">if</span> ((i &amp; j) == <span class="hljs-number">0</span> &amp;&amp; st[i | j])<br>                state[i].<span class="hljs-built_in">push_back</span>(j);<br>            &#125;<br>            <span class="hljs-comment">// cout &lt;&lt; state[i].size() &lt;&lt; endl;</span><br>        &#125;<br>        <br>        <span class="hljs-built_in">memset</span>(f, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> f);<br>        <span class="hljs-comment">//dp</span><br>        f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i ++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">1</span> &lt;&lt; n; j ++)<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> k : state[j])<br>                    f[i][j] += f[i - <span class="hljs-number">1</span>][k];<br>                    <br>        cout &lt;&lt; f[m][<span class="hljs-number">0</span>] &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/93/"><strong>最短Hamilton路径</strong></a></p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">状态表示：f[i][j]:从0走到j点的路径经过的点集合为i的所有路径最短的长度</span><br><span class="hljs-comment">状态转移：f[i][j] = min(f[i-(j)][k]) + w[k][j], 枚举倒数第二个点k，表示从0走到k的点最小路径长度，再从k走到j点</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">21</span>, M = <span class="hljs-number">1</span> &lt;&lt; N;<br><span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">int</span> w[N][N];<br><span class="hljs-keyword">int</span> f[M][N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j ++)<br>            cin &gt;&gt; w[i][j];<br>    <br>    <span class="hljs-built_in">memset</span>(f, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> f);<br>    f[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1</span> &lt;&lt; n; i ++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j ++)<br>            <span class="hljs-keyword">if</span> (i &gt;&gt; j &amp; <span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; n; k ++)<br>                    <span class="hljs-keyword">if</span> (i - (<span class="hljs-number">1</span> &lt;&lt; j) &gt;&gt; k &amp; <span class="hljs-number">1</span>)<br>                        f[i][j] = <span class="hljs-built_in">min</span>(f[i][j], f[i - (<span class="hljs-number">1</span> &lt;&lt; j)][k] + w[k][j]);<br>                        <br>    cout &lt;&lt; f[(<span class="hljs-number">1</span> &lt;&lt; n) - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="5-10-树形DP"><a href="#5-10-树形DP" class="headerlink" title="5.10 树形DP"></a>5.10 树形DP</h2><p> 解决的是树形结构的问题：通过子树的状态，转移到当前树的状态</p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/287/"><strong>没有上司的舞会</strong></a></p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">f[u][0]:表示以u为根节点的子树，不选u的最大值</span><br><span class="hljs-comment">f[u][1]:表示以u为根节点的子树，选u的最大值</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">f[u][0] = sum(max(f[j][0], f[j][1])): 	j为u的子节点</span><br><span class="hljs-comment">f[u][1] = happy[u] + sum(f[j][0]):		j为u的子节点</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">6010</span>;<br><span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">int</span> happy[N];<br><span class="hljs-keyword">int</span> h[N], e[N], ne[N], idx;<br><span class="hljs-keyword">int</span> f[N][<span class="hljs-number">2</span>];<br><span class="hljs-keyword">bool</span> has_fat[N];<br><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    f[u][<span class="hljs-number">1</span>] = happy[u];<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = h[u]; i != <span class="hljs-number">-1</span>; i = ne[i]) &#123;<br>        <span class="hljs-keyword">int</span> j = e[i];<br>        <span class="hljs-built_in">dfs</span>(j);<br>        f[u][<span class="hljs-number">1</span>] += f[j][<span class="hljs-number">0</span>];<br>        f[u][<span class="hljs-number">0</span>] += <span class="hljs-built_in">max</span>(f[j][<span class="hljs-number">0</span>], f[j][<span class="hljs-number">1</span>]);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;happy[i]);<br>    <br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i ++)<br>    &#123;<br>        <span class="hljs-keyword">int</span> a, b;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);<br>        has_fat[a] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-built_in">add</span>(b, a);<br>    &#125;<br>    <br>    <span class="hljs-keyword">int</span> root = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (has_fat[root]) root ++;<br>    <br>    <span class="hljs-built_in">dfs</span>(root);<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in">max</span>(f[root][<span class="hljs-number">1</span>], f[root][<span class="hljs-number">0</span>]));<br>&#125;<br></code></pre></div></td></tr></table></figure>



<h2 id="5-11-记忆搜索"><a href="#5-11-记忆搜索" class="headerlink" title="5.11 记忆搜索"></a>5.11 记忆搜索</h2><p>优势：代码简单</p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/903/">滑雪</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">310</span>;<br><span class="hljs-keyword">int</span> n, m;<br><span class="hljs-keyword">int</span> h[N][N];<br><span class="hljs-keyword">int</span> f[N][N];<br><br><span class="hljs-keyword">int</span> dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;, dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span>  </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> &amp;v = f[x][y];<br>    <span class="hljs-keyword">if</span> (v != <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> v;<br>    <br>    v = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i ++)<br>    &#123;<br>        <span class="hljs-keyword">int</span> a = x + dx[i], b = y + dy[i];<br>        <span class="hljs-keyword">if</span> (a &gt;= <span class="hljs-number">1</span> &amp;&amp; a &lt;= n &amp;&amp; b &gt;= <span class="hljs-number">1</span> &amp;&amp; b &lt;= m &amp;&amp; h[a][b] &lt; h[x][y])<br>            v = <span class="hljs-built_in">max</span>(v, <span class="hljs-built_in">dp</span>(a, b) + <span class="hljs-number">1</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> v;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++)<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;h[i][j]);<br>    <br>    <span class="hljs-built_in">memset</span>(f, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> f);<br>    <br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++)<br>            res = <span class="hljs-built_in">max</span>(res, <span class="hljs-built_in">dp</span>(i, j));<br>            <br>    cout &lt;&lt; res &lt;&lt;endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="5-12-数字三角形模型"><a href="#5-12-数字三角形模型" class="headerlink" title="5.12 数字三角形模型"></a>5.12 数字三角形模型</h2><h1 id="6-贪心"><a href="#6-贪心" class="headerlink" title="6. 贪心"></a>6. 贪心</h1><h2 id="6-1-区间问题"><a href="#6-1-区间问题" class="headerlink" title="6.1 区间问题"></a>6.1 区间问题</h2><p>区间问题的贪心，一般要以区间左端点或者区间右端点排序，再去尝试。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/AcWing/">AcWing</a>
                    
                      <a class="hover-with-bg" href="/tags/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/">算法基础</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/09/28/AcWing%E7%AC%AC18%E5%9C%BA%E5%91%A8%E8%B5%9B/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">AcWing第18场周赛</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/09/20/win7-USB%E7%BD%91%E5%8D%A1%E5%BC%80%E7%83%AD%E7%82%B9/">
                        <span class="hidden-mobile">win7-USB网卡开热点</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  




















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
