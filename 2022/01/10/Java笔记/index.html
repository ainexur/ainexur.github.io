<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible"><meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,minimum-scale=1,user-scalable=no"><meta name="renderer" content="webkit"><meta name="color-scheme" content="dark light"><meta name="author" content="ainexur"><meta name="description" content="温故 知新"><meta name="keywords" content="博客"><title>Java笔记</title><link rel="icon" type="image/x-icon" href="/images/favicon.ico"><link rel="stylesheet" href="//at.alicdn.com/t/font_3242539_utq6ykfq7z.css"><link rel="stylesheet" light-src="https://cdn.staticfile.org/highlight.js/11.5.0/styles/default.min.css" dark-src="https://cdn.staticfile.org/highlight.js/11.5.0/styles/tokyo-night-dark.min.css"><link rel="stylesheet" href="https://fonts.font.im/css?family=Noto+Serif" as="font"><link href="/style/index.css" rel="stylesheet"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="寻人启事" type="application/atom+xml">
</head><body><header class="page-header"><nav><ul class="router-list"><li class="nav-item"> <a href="/">主页</a></li><li class="nav-item"> <a href="/archives/">归档</a></li><li class="nav-item"> <a href="/atom.xml">RSS</a></li></ul><div class="mode-switch"><span class="iconfont icon-DarkTheme"></span></div></nav></header><main><section class="main-content"><section class="post-page"><div class="title-bar"><h1>Java笔记</h1><div class="post-info"><span>2022-01-10 13:18:51</span><span class="tags"><a href="/tags/Java/">#Java</a><a href="/tags/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">#Java面向对象</a></span></div></div><article> <div class="content"><h1 id="Java笔记"><a href="#Java笔记" class="headerlink" title="Java笔记"></a>Java笔记</h1><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="1-重载"><a href="#1-重载" class="headerlink" title="1 重载"></a>1 重载</h3><p>方法重载：具有多个同名方法称为方法的重载。前提是不同方法之间的参数列表互不相同，例如参数个数、参数顺序、参数类型都可以算做不同的参数列表。返回值不同不能作为重载的依据。</p>
<p>注意：构造方法也可以重载。无参构造方法执行时，类内部没有执行初始化的属性将执行默认初始化。</p>
<h3 id="2-封装"><a href="#2-封装" class="headerlink" title="2 封装"></a>2 封装</h3><p>封装：将类的属性设置为private，再设置public方法。外部通过调用public方法获取或修改privae属性。</p>
<p>优势：加强权限控制。</p>
<p>劣势：代码繁琐（可通过插件，自动在编译时加上默认get\set方法，省去人工编写的工作量以及类代码更简洁）。</p>
<p>例子：</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;
    <span class="hljs-keyword">private</span> String className;
    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;
    
    Animal(String className, <span class="hljs-type">int</span> age)&#123;
        <span class="hljs-built_in">this</span>.className = className;
        <span class="hljs-built_in">this</span>.age = age;
    &#125;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setClassName</span><span class="hljs-params">(String className)</span>&#123;
        <span class="hljs-built_in">this</span>.className = className;
    &#125;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span>&#123;
        <span class="hljs-built_in">this</span>.age = age;
    &#125;

    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getClassName</span><span class="hljs-params">()</span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.className;
    &#125;

    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.age;
    &#125;
&#125;
</code></pre>



<h3 id="3-继承"><a href="#3-继承" class="headerlink" title="3 继承"></a>3 继承</h3><p>一个类继承另一个类的所有属性及方法称为继承。Java只支持单继承（C++支持多继承），避免了菱形继承。</p>
<p>Animal.java:</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">speak</span><span class="hljs-params">()</span>&#123;
        System.out.println(<span class="hljs-string">&quot;This is animal speaking!&quot;</span>);
    &#125;
&#125;</code></pre>



<p>Cat.java</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span>&#123;
&#125;</code></pre>



<p>Main.java</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;
        <span class="hljs-type">Cat</span> <span class="hljs-variable">cat</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();
        animal.speak();
    &#125;
&#125;</code></pre>

<p>输出：</p>
<pre><code class="hljs plaintext">This is animal speaking!</code></pre>

<p>解释：虽然Cat类未定义<code>speak()</code>方法，但继承了Animal类，所以也继承了Animal的<code>speak()</code>方法。</p>
<h4 id="3-1-重写"><a href="#3-1-重写" class="headerlink" title="3.1 重写"></a>3.1 重写</h4><p>子类重写父类方法称为重写。</p>
<p>建议：重写方法加上<code>@Override</code>注解，编译器将自动检查是否重写方法，避免人为的编码错误。</p>
<p>Cat.java</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">speak</span><span class="hljs-params">()</span>&#123;
        System.out.println(<span class="hljs-string">&quot;This is cat speaking!&quot;</span>);
    &#125;
&#125;</code></pre>

<p>输出：</p>
<pre><code class="hljs plaintext">This is cat speaking!</code></pre>

<p>解释：由于子类重写了父类方法，调用时将调用子类方法。</p>
<h4 id="3-2-子类方法重载"><a href="#3-2-子类方法重载" class="headerlink" title="3.2 子类方法重载"></a>3.2 子类方法重载</h4><p>Cat.java</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">speak</span><span class="hljs-params">()</span>&#123;
        System.out.println(<span class="hljs-string">&quot;This is cat speaking!&quot;</span>);
    &#125;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">speak</span><span class="hljs-params">(String info)</span>&#123;
        System.out.println(info);
    &#125;
&#125;
</code></pre>

<p>Main.java</p>
<pre><code class="hljs java"><span class="hljs-comment">// ……</span>
<span class="hljs-type">Cat</span> <span class="hljs-variable">cat</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();
cat.speak(<span class="hljs-string">&quot;A cat is speak!&quot;</span>);
<span class="hljs-comment">// ……</span></code></pre>

<p>output:</p>
<pre><code class="hljs java">A cat is speak!</code></pre>

<p>解释：子类方法可以与重写的方法重载，也可以与父类方法重载。</p>
<p>总结：</p>
<ul>
<li>当子类方法名和参数列表与父类方法一致时，子类方法将重写父类方法。</li>
<li>子类方法名和父类方法名一致，但参数列表不一致时，子类方法将与父类方法触发重载（无论子类是否重写父类方法）。</li>
</ul>
<h3 id="4-多态"><a href="#4-多态" class="headerlink" title="4 多态"></a>4 多态</h3><p>编译多态：方法重载。</p>
<p>运行多态：类指针指向父类或子类实例。</p>
<h4 id="4-1-指向子类实例"><a href="#4-1-指向子类实例" class="headerlink" title="4.1 指向子类实例"></a>4.1 指向子类实例</h4><p>new：</p>
<pre><code class="hljs java"><span class="hljs-type">Animal</span> <span class="hljs-variable">animal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();</code></pre>

<p>方法调用：</p>
<pre><code class="hljs java">animal.speak();</code></pre>

<p>输出：</p>
<pre><code class="hljs java">This is cat speaking!</code></pre>

<p>解释：虽然animal是Animal类，但animal是Cat实例，调用方法时将优先调用子类复写的方法。</p>
<p><del><strong>调用子类重载的方法：</strong></del></p>
<pre><code class="hljs java">animal.speak(<span class="hljs-string">&quot;A cat is speak!&quot;</span>);</code></pre>

<p>报错：’speak()’ in ‘多态.Animal’ cannot be applied to ‘(java.lang.String)’</p>
<p>解释：虽然animal是cat实例，但是animal对象。调用Cat的重载方法时，在animal中找不到该方法，IDE报错。</p>
<p>总结：对象指向子类实例时，只能调用父类有的方法和属性，优先调用子类重写的方法和属性。</p>
<h4 id="4-2-指向父类实例"><a href="#4-2-指向父类实例" class="headerlink" title="4.2 指向父类实例"></a>4.2 指向父类实例</h4><p>new:</p>
<pre><code class="hljs java"><span class="hljs-type">Cat</span> <span class="hljs-variable">cat</span> <span class="hljs-operator">=</span> (Cat)<span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>();</code></pre>

<p>方法调用：</p>
<pre><code class="hljs java">cat.speak(<span class="hljs-string">&quot;A cat is speak!&quot;</span>);  <span class="hljs-comment">//报错：找不到speak的重载方法</span></code></pre>

<p>运行报错：Animal cannot be cast to Cat</p>
<p>解释：虽然加上<code>(Cat)</code>强转类型在编码阶段不报错，但在运行时候提示无法强制类型转换。（原因不明）</p>
<h3 id="5-接口"><a href="#5-接口" class="headerlink" title="5 接口"></a>5 接口</h3><ul>
<li>接口不能拥有private属性、private抽象方法</li>
<li>接口的属性必须在声明时实例化</li>
<li>接口抽象方法不能拥有<code>body</code>（不能在接口实现抽象方法）</li>
<li>接口可省略<code>public</code>关键字，即接口的属性和方法只能是<code>public</code>类型</li>
<li>接口如要像实例化类一样实例化接口，须得在实例化时带上<code>&#39;body</code>(即实例化同时实现接口)）</li>
<li>接口可以像类一样使用多态</li>
</ul>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h1 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h1><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1></div></article><div class="copyright-wrapper"><p>原文作者:<a href="https://ainexur.github.io">ainexur</a></p><p>原文链接:<a href="https://ainexur.github.io/2022/01/10/Java%E7%AC%94%E8%AE%B0/">Java笔记</a></p><p>发表日期: 2022-01-10 13:18:51</p><p>更新日期: 2023-04-02 23:52:57</p><p>版权声明: 本文采用<a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc/4.0/">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可</p></div><div class="post-pager"><div class="prev"><a href="/2022/01/10/SpringBoot%E7%AC%94%E8%AE%B0/" title="SpringBoot笔记">上一篇 SpringBoot笔记</a></div><div class="next"> <a href="/2022/01/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/" title="计算机科学导论">下一篇 计算机科学导论</a></div></div><link rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.css"/><script src="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.js"></script><div id="gitalk-container"></div><script>new Gitalk({
  clientID: '',
  clientSecret: '',
  repo: '',
  owner: '',
  admin: '',
  id: location.pathname.substr(0, 48),
  distractionFreeMode: true,
  labels: ['Gitalk'],
  title: 'Java笔记',
}).render('gitalk-container');</script></section></section></main><footer class="footer-page"><div><span>Powered by</span><a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a><span>| Theme</span><a target="_blank" rel="noopener" href="https://github.com/techmovie/hexo-theme-instapaper">instapaper</a></div></footer><script src="/scripts/dark.js"></script><script src="/scripts/post.js"></script></body></html>