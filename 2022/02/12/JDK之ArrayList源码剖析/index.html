<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible"><meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,minimum-scale=1,user-scalable=no"><meta name="renderer" content="webkit"><meta name="color-scheme" content="dark light"><meta name="author" content="ainexur"><meta name="description" content="温故 知新"><meta name="keywords" content="博客"><title>JDK之ArrayList源码剖析</title><link rel="icon" type="image/x-icon" href="/images/favicon.ico"><link rel="stylesheet" href="//at.alicdn.com/t/font_3242539_utq6ykfq7z.css"><link rel="stylesheet" light-src="https://cdn.staticfile.org/highlight.js/11.5.0/styles/default.min.css" dark-src="https://cdn.staticfile.org/highlight.js/11.5.0/styles/tokyo-night-dark.min.css"><link rel="stylesheet" href="https://fonts.font.im/css?family=Noto+Serif" as="font"><link href="/style/index.css" rel="stylesheet"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="寻人启事" type="application/atom+xml">
</head><body><header class="page-header"><nav><ul class="router-list"><li class="nav-item"> <a href="/">主页</a></li><li class="nav-item"> <a href="/archives/">归档</a></li><li class="nav-item"> <a href="/atom.xml">RSS</a></li></ul><div class="mode-switch"><span class="iconfont icon-DarkTheme"></span></div></nav></header><main><section class="main-content"><section class="post-page"><div class="title-bar"><h1>JDK之ArrayList源码剖析</h1><div class="post-info"><span>2022-02-12 23:48:10</span><span class="tags"><a href="/tags/JDK/">#JDK</a><a href="/tags/Java/">#Java</a><a href="/tags/%E6%BA%90%E7%A0%81%E8%AE%A1%E5%88%92/">#源码计划</a><a href="/tags/ArrayList/">#ArrayList</a></span></div></div><article> <div class="content"><h1 id="ArrayList源码分析"><a href="#ArrayList源码分析" class="headerlink" title="ArrayList源码分析"></a>ArrayList源码分析</h1><p>基于<code>java version &quot;1.8.0_321&quot;</code></p>
<h2 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h2><p>ArrayList底层是用数组实现的，<code>Object</code>数组</p>
<pre><code class="hljs java"><span class="hljs-keyword">transient</span> Object[] elementData; <span class="hljs-comment">// non-private to simplify nested class access</span></code></pre>

<pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;	<span class="hljs-comment">//元素个数</span></code></pre>

<h2 id="扩容分析"><a href="#扩容分析" class="headerlink" title="扩容分析"></a>扩容分析</h2><p>看一下add方法：</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;
    ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span>
    elementData[size++] = e;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
&#125;</code></pre>

<p>在添加元素之前，会进行一个容量是否需要增长判断操作<code>ensureCapacityInternal(size + 1); </code>。</p>
<pre><code class="hljs java"><span class="hljs-comment">//2</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calculateCapacity</span><span class="hljs-params">(Object[] elementData, <span class="hljs-type">int</span> minCapacity)</span> &#123;
    <span class="hljs-keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;	<span class="hljs-comment">//如果数组是默认空元素数组</span>
        <span class="hljs-keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);	<span class="hljs-comment">// 将两者中较大的值作为minCapacity</span>
    &#125;
    <span class="hljs-keyword">return</span> minCapacity;	<span class="hljs-comment">//否则minCapacity不变</span>
&#125;
<span class="hljs-comment">//1</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;	<span class="hljs-comment">//</span>
    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));
&#125;
<span class="hljs-comment">//3</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureExplicitCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;
    modCount++;
    <span class="hljs-comment">// overflow-conscious code</span>
    <span class="hljs-keyword">if</span> (minCapacity - elementData.length &gt; <span class="hljs-number">0</span>)	<span class="hljs-comment">//如果需要的容量大于现有数组容量</span>
        grow(minCapacity);
&#125;</code></pre>

<p>如果当前数组的容量不足够放下元素个数，就执行<code>grow(minCapacity);</code>扩容</p>
<pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_ARRAY_SIZE</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE - <span class="hljs-number">8</span>;

<span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">grow</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;
    <span class="hljs-comment">// overflow-conscious code</span>
    <span class="hljs-type">int</span> <span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">=</span> elementData.length;
    <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>);
    <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>)	<span class="hljs-comment">//如果扩容1.5倍还不满足大小，就直接扩容到minCapacity</span>
    newCapacity = minCapacity;
    <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)	<span class="hljs-comment">//负数-正数，结果可能是正数，所以这个时候就需要特判容量是否溢出</span>
    newCapacity = hugeCapacity(minCapacity);	<span class="hljs-comment">//如果容量超过默认的最大容量，判断是否过大</span>
    <span class="hljs-comment">// minCapacity is usually close to size, so this is a win:</span>
    elementData = Arrays.copyOf(elementData, newCapacity);	<span class="hljs-comment">//将旧数组复制到新容量的数组返回</span>
&#125;

<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hugeCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;	<span class="hljs-comment">//判断容量是否超int大小</span>
    <span class="hljs-keyword">if</span> (minCapacity &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span>
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OutOfMemoryError</span>();
    <span class="hljs-keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?
        Integer.MAX_VALUE :
    MAX_ARRAY_SIZE;
&#125;</code></pre>

<p>由<code>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</code>判断，新的数组的容量是原来的1.5倍（<code>&gt;&gt;</code>右移等价于除以2）</p>
<p>要注意的是，扩容后的容量可能溢出变为负数，这时候就需要<code>hugeCapacity(minCapacity)</code>函数判断溢出这种情况.</p>
<h2 id="ArrayList常用方法复杂度分析"><a href="#ArrayList常用方法复杂度分析" class="headerlink" title="ArrayList常用方法复杂度分析"></a>ArrayList常用方法复杂度分析</h2><h3 id="add-E-e"><a href="#add-E-e" class="headerlink" title="add(E e)"></a>add(E e)</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;
    ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span>
    elementData[size++] = e;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
&#125;</code></pre>

<p>直接在元素列末尾添加一个元素,复杂度可看成O(1)</p>
<h3 id="add-int-index-E-element"><a href="#add-int-index-E-element" class="headerlink" title="add(int index, E element)"></a>add(int index, E element)</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> index, E element)</span> &#123;
    rangeCheckForAdd(index);

    ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span>
    System.arraycopy(elementData, index, elementData, index + <span class="hljs-number">1</span>,
                     size - index);
    elementData[index] = element;
    size++;
&#125;</code></pre>

<p>index及后的所有元素往后移一位,复杂度近似O(n)</p>
<h3 id="remove-int-index"><a href="#remove-int-index" class="headerlink" title="remove(int index)"></a>remove(int index)</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;
    rangeCheck(index);

    modCount++;
    <span class="hljs-type">E</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> elementData(index);

    <span class="hljs-type">int</span> <span class="hljs-variable">numMoved</span> <span class="hljs-operator">=</span> size - index - <span class="hljs-number">1</span>;
    <span class="hljs-keyword">if</span> (numMoved &gt; <span class="hljs-number">0</span>)
        System.arraycopy(elementData, index+<span class="hljs-number">1</span>, elementData, index,
                         numMoved);
    elementData[--size] = <span class="hljs-literal">null</span>; <span class="hljs-comment">// clear to let GC do its work</span>

    <span class="hljs-keyword">return</span> oldValue;
&#125;</code></pre>

<p>删除指定位置的元素,其他的所有元素往前移一位,O(n)</p>
<h3 id="remove-Object-o"><a href="#remove-Object-o" class="headerlink" title="remove(Object o)"></a>remove(Object o)</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Object o)</span> &#123;
    <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span>) &#123;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; index &lt; size; index++)
            <span class="hljs-keyword">if</span> (elementData[index] == <span class="hljs-literal">null</span>) &#123;
                fastRemove(index);
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            &#125;
    &#125; <span class="hljs-keyword">else</span> &#123;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; index &lt; size; index++)
            <span class="hljs-keyword">if</span> (o.equals(elementData[index])) &#123;
                fastRemove(index);
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            &#125;
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
&#125;</code></pre>

<p>删除首个指定元素,其后所有元素往前移一位O(n)</p>
<h3 id="indexOf-Object-o"><a href="#indexOf-Object-o" class="headerlink" title="indexOf(Object o)"></a>indexOf(Object o)</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">indexOf</span><span class="hljs-params">(Object o)</span> &#123;
    <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span>) &#123;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++)
            <span class="hljs-keyword">if</span> (elementData[i]==<span class="hljs-literal">null</span>)
                <span class="hljs-keyword">return</span> i;
    &#125; <span class="hljs-keyword">else</span> &#123;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++)
            <span class="hljs-keyword">if</span> (o.equals(elementData[i]))
                <span class="hljs-keyword">return</span> i;
    &#125;
    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
&#125;</code></pre>

<p>O(n)</p>
<h3 id="contains-Object-o"><a href="#contains-Object-o" class="headerlink" title="contains(Object o)"></a>contains(Object o)</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">contains</span><span class="hljs-params">(Object o)</span> &#123;
    <span class="hljs-keyword">return</span> indexOf(o) &gt;= <span class="hljs-number">0</span>;
&#125;</code></pre>

<p>O(n)</p>
<h3 id="clear"><a href="#clear" class="headerlink" title="clear()"></a>clear()</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span> &#123;
    modCount++;

    <span class="hljs-comment">// clear to let GC do its work</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++)
        elementData[i] = <span class="hljs-literal">null</span>;

    size = <span class="hljs-number">0</span>;
&#125;</code></pre>

<p>将所有有元素的索引置null,不缩减容量.O(n)</p>
<h3 id="addAll-Collection-lt-extends-E-gt-c"><a href="#addAll-Collection-lt-extends-E-gt-c" class="headerlink" title="addAll(Collection&lt;? extends E&gt; c)"></a>addAll(Collection&lt;? extends E&gt; c)</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">addAll</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> &#123;
    Object[] a = c.toArray();
    <span class="hljs-type">int</span> <span class="hljs-variable">numNew</span> <span class="hljs-operator">=</span> a.length;
    ensureCapacityInternal(size + numNew);  <span class="hljs-comment">// Increments modCount</span>
    System.arraycopy(a, <span class="hljs-number">0</span>, elementData, size, numNew);
    size += numNew;
    <span class="hljs-keyword">return</span> numNew != <span class="hljs-number">0</span>;
&#125;</code></pre>

<p>将集合的所有元素追加至末尾,复杂度O(k),k为集合的元素个数</p>
<p>addAll(int index, Collection&lt;? extends E&gt; c)</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">addAll</span><span class="hljs-params">(<span class="hljs-type">int</span> index, Collection&lt;? extends E&gt; c)</span> &#123;
    rangeCheckForAdd(index);

    Object[] a = c.toArray();
    <span class="hljs-type">int</span> <span class="hljs-variable">numNew</span> <span class="hljs-operator">=</span> a.length;
    ensureCapacityInternal(size + numNew);  <span class="hljs-comment">// Increments modCount</span>

    <span class="hljs-type">int</span> <span class="hljs-variable">numMoved</span> <span class="hljs-operator">=</span> size - index;
    <span class="hljs-keyword">if</span> (numMoved &gt; <span class="hljs-number">0</span>)
        System.arraycopy(elementData, index, elementData, index + numNew,
                         numMoved);

    System.arraycopy(a, <span class="hljs-number">0</span>, elementData, index, numNew);
    size += numNew;
    <span class="hljs-keyword">return</span> numNew != <span class="hljs-number">0</span>;
&#125;</code></pre>

<p>将集合所有元素追加至具体位置上,其后所有元素往后移k位,复杂度O(n + k)	</p>
</div></article><div class="copyright-wrapper"><p>原文作者:<a href="https://ainexur.github.io">ainexur</a></p><p>原文链接:<a href="https://ainexur.github.io/2022/02/12/JDK%E4%B9%8BArrayList%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/">JDK之ArrayList源码剖析</a></p><p>发表日期: 2022-02-12 23:48:10</p><p>更新日期: 2023-04-02 23:52:57</p><p>版权声明: 本文采用<a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc/4.0/">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可</p></div><div class="post-pager"><div class="prev"><a href="/2022/02/27/fastjson%E4%B9%8B%E7%B1%BB%E6%A8%A1%E6%9D%BFparseObject/" title="fastjson之类模板parseObject">上一篇 fastjson之类模板parseObject</a></div><div class="next"> <a href="/2022/02/10/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F/" title="十个经典排序">下一篇 十个经典排序</a></div></div><link rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.css"/><script src="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.js"></script><div id="gitalk-container"></div><script>new Gitalk({
  clientID: '',
  clientSecret: '',
  repo: '',
  owner: '',
  admin: '',
  id: location.pathname.substr(0, 48),
  distractionFreeMode: true,
  labels: ['Gitalk'],
  title: 'JDK之ArrayList源码剖析',
}).render('gitalk-container');</script></section></section></main><footer class="footer-page"><div><span>Powered by</span><a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a><span>| Theme</span><a target="_blank" rel="noopener" href="https://github.com/techmovie/hexo-theme-instapaper">instapaper</a></div></footer><script src="/scripts/dark.js"></script><script src="/scripts/post.js"></script></body></html>